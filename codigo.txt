--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\.env ---
EXPO_PUBLIC_FIREBASE_API_KEY=AIzaSyAJ5MjRiGWgtv8ikYoHZu6zR2i5HceXt18
EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN=expo-wip.firebaseapp.com
EXPO_PUBLIC_FIREBASE_PROJECT_ID=expo-wip
EXPO_PUBLIC_FIREBASE_STORAGE_BUCKET=expo-wip.firebasestorage.app
EXPO_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=246301729624
EXPO_PUBLIC_FIREBASE_APP_ID=1:246301729624:web:5b74da5b75f2e07a737b2d
EXPO_PUBLIC_GOOGLE_ANDROID_CLIENT_ID=246301729624-l6eug791jism76iig52cc06hboqrnoed.apps.googleusercontent.com
EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID=246301729624-uh4dv4td4bpdakqtl5qjbl5i7rrsb02p.apps.googleusercontent.com
EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID=246301729624-600k5mepa4ukhm21m67lq9f4mlii5nvm.apps.googleusercontent.com
EXPO_PUBLIC_GOOGLE_MAPS_API_KEY=AIzaSyAGdcIjjTYnx4gPzD77wSQ7MTgVzAGPbsc

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\.gitignore ---
# dependencies
node_modules/

# expo
.expo/
dist/
web-build/

# native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macos
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\.prettierrc ---
{
  "useTabs": false,
  "bracketSpacing": true,
  "singleQuote": true,
  "tabWidth": 2
}


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app.config.js ---
module.exports = {
  expo: {
    extra: {
      firebaseApiKey: process.env.EXPO_PUBLIC_FIREBASE_API_KEY,
      firebaseAuthDomain: process.env.EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN,
      firebaseProjectId: process.env.EXPO_PUBLIC_FIREBASE_PROJECT_ID,
      firebaseStorageBucket: process.env.EXPO_PUBLIC_FIREBASE_STORAGE_BUCKET,
      firebaseMessagingSenderId: process.env.EXPO_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
      firebaseAppId: process.env.EXPO_PUBLIC_FIREBASE_APP_ID,
    }
  }
};

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app.json ---
{
  "expo": {
    "name": "wip",
    "slug": "wip",
    "version": "1.0.0",
    "orientation": "portrait",
    "scheme": "wip",
    "userInterfaceStyle": "automatic",
    "splash": {
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": ["**/*"],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.wip",
      "newArchEnabled": true
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.wip"
    },
    "web": {
      "bundler": "metro",
      "output": "static"
    },
    "plugins": ["expo-router"],
    "experiments": {
      "typedRoutes": true,
      "tsconfigPaths": true
    }
  }
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\babel.config.js ---
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      'expo-router/babel',
      [
        'module-resolver',
        {
          root: ['.'],
          alias: {
            '@': '.'
          }
        }
      ]
    ]
  };
};

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\codigo.txt ---


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\export.py ---
import os

# Caminho da pasta de origem e do arquivo de saída
source_dir = r"C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project"
output_file = os.path.join(source_dir, "codigo.txt")

# Extensões de imagem a serem excluídas
image_extensions = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg'}

def read_and_compile_files(source_dir, output_file):
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(source_dir):
            # Excluir a pasta node_modules
            if 'node_modules' in dirs:
                dirs.remove('node_modules')

            for file in files:
                # Excluir o arquivo package-lock.json e arquivos de imagem
                if file == 'package-lock.json' or os.path.splitext(file)[1] in image_extensions:
                    continue

                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as infile:
                    outfile.write(f"--- Conteúdo do arquivo: {file_path} ---\n")
                    outfile.write(infile.read())
                    outfile.write("\n\n")

read_and_compile_files(source_dir, output_file)


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\metro.config.js ---
const { getDefaultConfig } = require('expo/metro-config');

const config = getDefaultConfig(__dirname);

// Aumentar o limite de memória e otimizar o cache
config.maxWorkers = 2;
config.resetCache = true;
config.cacheStores = [];

module.exports = config;

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\package.json ---
{
  "name": "wip",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "EXPO_NO_TELEMETRY=1 NODE_OPTIONS=--max_old_space_size=4096 expo start --clear",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "build:web": "expo export --platform web",
    "lint": "eslint .",
    "clean": "rm -rf node_modules/.cache"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.0",
    "@expo/webpack-config": "^19.0.0",
    "@react-native-picker/picker": "2.4.10",
    "@react-navigation/native": "^6.1.9",
    "babel-plugin-module-resolver": "^5.0.0",
    "chart.js": "^4.4.1",
    "date-fns": "^3.3.1",
    "expo": "~49.0.15",
    "expo-constants": "~14.4.2",
    "expo-device": "~5.4.0",
    "expo-localization": "~14.3.0",
    "expo-notifications": "~0.20.1",
    "expo-router": "^2.0.0",
    "expo-status-bar": "~1.6.0",
    "firebase": "^10.8.0",
    "i18n-js": "^4.3.2",
    "react": "18.2.0",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "18.2.0",
    "react-native": "0.72.6",
    "react-native-safe-area-context": "4.6.3",
    "react-native-screens": "~3.22.0",
    "react-native-web": "~0.19.6"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/node": "^20.11.19",
    "@types/react": "~18.2.14",
    "typescript": "^5.1.3"
  },
  "overrides": {
    "react-native-safe-area-context": "4.6.3"
  },
  "resolutions": {
    "react-native-safe-area-context": "4.6.3"
  }
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\tsconfig.json ---
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "jsx": "react-native",
    "types": [
      "node",
      "jest"
    ],
    "allowJs": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true
  },
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\webpack.config.js ---
const createExpoWebpackConfigAsync = require('@expo/webpack-config');

module.exports = async function (env, argv) {
  const config = await createExpoWebpackConfigAsync(env, argv);
  
  // Customize the config before returning it.
  return config;
};

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\.bolt\config.json ---
{
  "template": "bolt-expo"
}


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\.expo\devices.json ---
{
  "devices": []
}


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\.expo\README.md ---
> Why do I have a folder named ".expo" in my project?
The ".expo" folder is created when an Expo project is started using "expo start" command.
> What do the files contain?
- "devices.json": contains information about devices that have recently opened this project. This is used to populate the "Development sessions" list in your development builds.
- "settings.json": contains the server configuration that is used to serve the application manifest.
> Should I commit the ".expo" folder?
No, you should not share the ".expo" folder. It does not contain any information that is relevant for other developers working on the project, it is specific to your machine.
Upon project creation, the ".expo" folder is already added to your ".gitignore" file.


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\.expo\types\router.d.ts ---
/* eslint-disable */
import * as Router from 'expo-router';

export * from 'expo-router';

declare module 'expo-router' {
  export namespace ExpoRouter {
    export interface __routes<T extends string | object = string> {
      hrefInputParams: { pathname: Router.RelativePathString, params?: Router.UnknownInputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownInputParams } | { pathname: `/edit-artist-profile`; params?: Router.UnknownInputParams; } | { pathname: `/edit-contractor-profile`; params?: Router.UnknownInputParams; } | { pathname: `/home-artist`; params?: Router.UnknownInputParams; } | { pathname: `/home-contractor`; params?: Router.UnknownInputParams; } | { pathname: `/home`; params?: Router.UnknownInputParams; } | { pathname: `/`; params?: Router.UnknownInputParams; } | { pathname: `/login`; params?: Router.UnknownInputParams; } | { pathname: `/register`; params?: Router.UnknownInputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownInputParams; } | { pathname: `/+not-found`, params: Router.UnknownInputParams & {  } };
      hrefOutputParams: { pathname: Router.RelativePathString, params?: Router.UnknownOutputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownOutputParams } | { pathname: `/edit-artist-profile`; params?: Router.UnknownOutputParams; } | { pathname: `/edit-contractor-profile`; params?: Router.UnknownOutputParams; } | { pathname: `/home-artist`; params?: Router.UnknownOutputParams; } | { pathname: `/home-contractor`; params?: Router.UnknownOutputParams; } | { pathname: `/home`; params?: Router.UnknownOutputParams; } | { pathname: `/`; params?: Router.UnknownOutputParams; } | { pathname: `/login`; params?: Router.UnknownOutputParams; } | { pathname: `/register`; params?: Router.UnknownOutputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownOutputParams; } | { pathname: `/+not-found`, params: Router.UnknownOutputParams & {  } };
      href: Router.RelativePathString | Router.ExternalPathString | `/edit-artist-profile${`?${string}` | `#${string}` | ''}` | `/edit-contractor-profile${`?${string}` | `#${string}` | ''}` | `/home-artist${`?${string}` | `#${string}` | ''}` | `/home-contractor${`?${string}` | `#${string}` | ''}` | `/home${`?${string}` | `#${string}` | ''}` | `/${`?${string}` | `#${string}` | ''}` | `/login${`?${string}` | `#${string}` | ''}` | `/register${`?${string}` | `#${string}` | ''}` | `/_sitemap${`?${string}` | `#${string}` | ''}` | { pathname: Router.RelativePathString, params?: Router.UnknownInputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownInputParams } | { pathname: `/edit-artist-profile`; params?: Router.UnknownInputParams; } | { pathname: `/edit-contractor-profile`; params?: Router.UnknownInputParams; } | { pathname: `/home-artist`; params?: Router.UnknownInputParams; } | { pathname: `/home-contractor`; params?: Router.UnknownInputParams; } | { pathname: `/home`; params?: Router.UnknownInputParams; } | { pathname: `/`; params?: Router.UnknownInputParams; } | { pathname: `/login`; params?: Router.UnknownInputParams; } | { pathname: `/register`; params?: Router.UnknownInputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownInputParams; } | `/+not-found` | { pathname: `/+not-found`, params: Router.UnknownInputParams & {  } };
    }
  }
}


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\+not-found.tsx ---
import { Link, Stack } from 'expo-router';
import { StyleSheet, Text, View } from 'react-native';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <View style={styles.container}>
        <Text style={styles.text}>This screen doesn't exist.</Text>
        <Link href="/" style={styles.link}>
          <Text>Go to home screen!</Text>
        </Link>
      </View>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  text: {
    fontSize: 20,
    fontWeight: 600,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});


--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\artist-agenda.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert, TextInput } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, getDocs, addDoc, doc, getDoc, deleteDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { AvailabilityBlock, User } from '../src/types';

const MAX_FREE_BLOCKS = 10;

export default function ArtistAgendaScreen() {
  const [blocks, setBlocks] = useState<AvailabilityBlock[]>([]);
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<User | null>(null);
  const [showAddForm, setShowAddForm] = useState(false);
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');

  useEffect(() => {
    loadAgenda();
  }, []);

  const loadAgenda = async () => {
    if (!auth.currentUser) return;

    try {
      const [userDoc, blocksSnapshot] = await Promise.all([
        getDoc(doc(db, 'users', auth.currentUser.uid)),
        getDocs(query(
          collection(db, 'artistAgenda'),
          where('artistId', '==', auth.currentUser.uid)
        ))
      ]);

      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }

      const blocksList = blocksSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        startDate: doc.data().startDate.toDate(),
        endDate: doc.data().endDate.toDate(),
      })) as AvailabilityBlock[];

      setBlocks(blocksList.sort((a, b) => a.startDate.getTime() - b.startDate.getTime()));
    } catch (error) {
      console.error('Error loading agenda:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleAddBlock = async () => {
    if (!auth.currentUser) return;

    if (user?.planId === 'free' && blocks.filter(b => b.status === 'FREE').length >= MAX_FREE_BLOCKS) {
      Alert.alert(i18n.t('agenda.error.maxBlocks'));
      return;
    }

    try {
      const start = new Date(startDate);
      const end = new Date(endDate);

      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        Alert.alert(i18n.t('agenda.error.invalidDates'));
        return;
      }

      if (end <= start) {
        Alert.alert(i18n.t('agenda.error.endBeforeStart'));
        return;
      }

      // Check for conflicts
      const conflicts = blocks.some(block => {
        return (start <= block.endDate && end >= block.startDate);
      });

      if (conflicts) {
        Alert.alert(i18n.t('agenda.error.dateConflict'));
        return;
      }

      await addDoc(collection(db, 'artistAgenda'), {
        artistId: auth.currentUser.uid,
        startDate: start,
        endDate: end,
        status: 'FREE',
        createdAt: new Date(),
      });

      setShowAddForm(false);
      setStartDate('');
      setEndDate('');
      loadAgenda();
    } catch (error) {
      console.error('Error adding block:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleDeleteBlock = async (block: AvailabilityBlock) => {
    if (block.status === 'BUSY') {
      Alert.alert(i18n.t('agenda.error.deleteBusy'));
      return;
    }

    try {
      await deleteDoc(doc(db, 'artistAgenda', block.id));
      loadAgenda();
    } catch (error) {
      console.error('Error deleting block:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="calendar" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('agenda.title')}</Text>
        </View>

        {user?.planId === 'free' && (
          <Text style={styles.limitText}>
            {i18n.t('agenda.blocksLimit', { current: blocks.filter(b => b.status === 'FREE').length, max: MAX_FREE_BLOCKS })}
          </Text>
        )}

        {!showAddForm ? (
          <Button
            title={i18n.t('agenda.addBlock')}
            onPress={() => setShowAddForm(true)}
          />
        ) : (
          <View style={styles.form}>
            <Text style={styles.label}>{i18n.t('agenda.startDate')}</Text>
            <TextInput
              style={styles.input}
              value={startDate}
              onChangeText={setStartDate}
              placeholder="YYYY-MM-DD HH:mm"
            />

            <Text style={styles.label}>{i18n.t('agenda.endDate')}</Text>
            <TextInput
              style={styles.input}
              value={endDate}
              onChangeText={setEndDate}
              placeholder="YYYY-MM-DD HH:mm"
            />

            <View style={styles.formButtons}>
              <Button
                title={i18n.t('common.button.save')}
                onPress={handleAddBlock}
              />
              <Button
                title={i18n.t('common.button.cancel')}
                onPress={() => setShowAddForm(false)}
                variant="secondary"
              />
            </View>
          </View>
        )}

        {blocks.map((block) => (
          <View key={block.id} style={styles.blockItem}>
            <View style={styles.blockHeader}>
              <View style={[styles.statusBadge, styles[`status${block.status}`]]}>
                <Text style={styles.statusText}>
                  {i18n.t(`agenda.status.${block.status.toLowerCase()}`)}
                </Text>
              </View>
              {block.status === 'FREE' && (
                <TouchableOpacity
                  onPress={() => handleDeleteBlock(block)}
                  style={styles.deleteButton}
                >
                  <Ionicons name="trash-outline" size={24} color="#F44336" />
                </TouchableOpacity>
              )}
            </View>

            <View style={styles.blockDetails}>
              <Text style={styles.dateText}>
                <Ionicons name="time-outline" size={16} />
                {' '}
                {block.startDate.toLocaleString()} - {block.endDate.toLocaleString()}
              </Text>
            </View>
          </View>
        ))}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  limitText: {
    textAlign: 'center',
    color: '#666',
    marginBottom: 20,
  },
  form: {
    backgroundColor: '#fff',
    padding: 15,
    borderRadius: 8,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  formButtons: {
    gap: 10,
  },
  blockItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  blockHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
  },
  statusFREE: {
    backgroundColor: '#4CAF50',
  },
  statusBUSY: {
    backgroundColor: '#F44336',
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  blockDetails: {
    marginTop: 5,
  },
  dateText: {
    fontSize: 14,
    color: '#666',
  },
  deleteButton: {
    padding: 5,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\artist-dashboard.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Platform } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, getDocs, doc, getDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import { format, subDays, isWithinInterval, startOfDay, endOfDay } from 'date-fns';
import i18n from '../src/i18n';
import type { User, Candidacy, Media } from '../src/types';

// Import Chart.js components only on web platform
let Line: any;
if (Platform.OS === 'web') {
  const { Line: WebLine } = require('react-chartjs-2');
  const { Chart, registerables } = require('chart.js');
  Chart.register(...registerables);
  Line = WebLine;
}

type Period = '7d' | '30d' | 'custom';
type ChartData = { dates: string[]; values: number[] };

export default function ArtistDashboardScreen() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [period, setPeriod] = useState<Period>('7d');
  const [candidaciesData, setCandidaciesData] = useState<{
    total: number;
    approved: number;
    rejected: number;
    chart: ChartData;
  }>({
    total: 0,
    approved: 0,
    rejected: 0,
    chart: { dates: [], values: [] },
  });
  const [portfolioData, setPortfolioData] = useState<{
    totalViews: number;
    chart: ChartData;
  }>({
    totalViews: 0,
    chart: { dates: [], values: [] },
  });
  const [ratingData, setRatingData] = useState<{
    average: number;
    total: number;
    recent: number;
  }>({
    average: 0,
    total: 0,
    recent: 0,
  });

  useEffect(() => {
    loadDashboard();
  }, [period]);

  const loadDashboard = async () => {
    if (!auth.currentUser) return;

    try {
      // Load user data
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }

      const periodDays = period === '7d' ? 7 : 30;
      const startDate = subDays(new Date(), periodDays);

      // Load candidacies
      const candidaciesSnapshot = await getDocs(query(
        collection(db, 'candidacies'),
        where('artistId', '==', auth.currentUser.uid)
      ));

      const candidacies = candidaciesSnapshot.docs.map(doc => ({
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
      })) as Candidacy[];

      const recentCandidacies = candidacies.filter(c => 
        isWithinInterval(c.createdAt, {
          start: startOfDay(startDate),
          end: endOfDay(new Date()),
        })
      );

      // Generate dates array for charts
      const dates = Array.from({ length: periodDays }, (_, i) => {
        const date = subDays(new Date(), i);
        return format(date, 'yyyy-MM-dd');
      }).reverse();

      // Calculate candidacies per day
      const candidaciesPerDay = dates.map(date => {
        return recentCandidacies.filter(c => 
          format(c.createdAt, 'yyyy-MM-dd') === date
        ).length;
      });

      setCandidaciesData({
        total: candidacies.length,
        approved: candidacies.filter(c => c.status === 'APROVADA').length,
        rejected: candidacies.filter(c => c.status === 'REJEITADA').length,
        chart: {
          dates,
          values: candidaciesPerDay,
        },
      });

      // Load portfolio views
      const mediaSnapshot = await getDocs(query(
        collection(db, 'media'),
        where('userId', '==', auth.currentUser.uid)
      ));

      const media = mediaSnapshot.docs.map(doc => doc.data()) as Media[];
      const totalViews = media.reduce((sum, m) => sum + (m.viewsCount || 0), 0);

      // Calculate views per day if viewsHistory exists
      const viewsPerDay = dates.map(date => {
        return media.reduce((sum, m) => {
          if (m.viewsHistory && m.viewsHistory[date]) {
            return sum + m.viewsHistory[date];
          }
          return sum;
        }, 0);
      });

      setPortfolioData({
        totalViews,
        chart: {
          dates,
          values: viewsPerDay,
        },
      });

      // Load rating data
      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        const reviewsSnapshot = await getDocs(query(
          collection(db, 'reviews'),
          where('reviewedId', '==', auth.currentUser.uid)
        ));

        const reviews = reviewsSnapshot.docs.map(doc => ({
          ...doc.data(),
          createdAt: doc.data().createdAt.toDate(),
        }));

        const recentReviews = reviews.filter(r =>
          isWithinInterval(r.createdAt, {
            start: startOfDay(startDate),
            end: endOfDay(new Date()),
          })
        );

        setRatingData({
          average: userData.rating || 0,
          total: userData.reviewCount || 0,
          recent: recentReviews.length,
        });
      }
    } catch (error) {
      console.error('Error loading dashboard:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderChart = (data: ChartData, label: string, color: string) => {
    if (Platform.OS !== 'web') {
      return (
        <View style={styles.simpleChart}>
          {data.values.map((value, index) => (
            <View
              key={index}
              style={[
                styles.chartBar,
                {
                  height: `${(value / Math.max(...data.values)) * 100}%`,
                  backgroundColor: color,
                },
              ]}
            />
          ))}
        </View>
      );
    }

    return (
      <Line
        data={{
          labels: data.dates.map(date => format(new Date(date), 'dd/MM')),
          datasets: [
            {
              label,
              data: data.values,
              fill: false,
              borderColor: color,
              tension: 0.1,
            },
          ],
        }}
        options={{
          responsive: true,
          plugins: {
            legend: {
              position: 'top' as const,
            },
          },
          scales: {
            y: {
              beginAtZero: true,
            },
          },
        }}
      />
    );
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="stats-chart" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('dashboard.artist.title')}</Text>
        </View>

        <View style={styles.periodSelector}>
          <Button
            title="7 dias"
            onPress={() => setPeriod('7d')}
            variant={period === '7d' ? 'primary' : 'secondary'}
          />
          <Button
            title="30 dias"
            onPress={() => setPeriod('30d')}
            variant={period === '30d' ? 'primary' : 'secondary'}
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{i18n.t('dashboard.artist.candidacies')}</Text>
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{candidaciesData.total}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.artist.totalCandidacies')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#4CAF50' }]}>{candidaciesData.approved}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.artist.approvedCandidacies')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#F44336' }]}>{candidaciesData.rejected}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.artist.rejectedCandidacies')}</Text>
            </View>
          </View>
          <View style={styles.chart}>
            {renderChart(
              candidaciesData.chart,
              i18n.t('dashboard.artist.candidaciesChart'),
              '#007AFF'
            )}
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{i18n.t('dashboard.artist.portfolio')}</Text>
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{portfolioData.totalViews}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.artist.totalViews')}</Text>
            </View>
          </View>
          <View style={styles.chart}>
            {renderChart(
              portfolioData.chart,
              i18n.t('dashboard.artist.viewsChart'),
              '#4CAF50'
            )}
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{i18n.t('dashboard.artist.rating')}</Text>
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{ratingData.average.toFixed(1)}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.artist.averageRating')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{ratingData.total}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.artist.totalReviews')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{ratingData.recent}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.artist.recentReviews')}</Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  periodSelector: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 10,
    marginBottom: 20,
  },
  section: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  statCard: {
    width: '31%',
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    padding: 15,
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#007AFF',
    marginBottom: 5,
  },
  statLabel: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
  },
  chart: {
    height: 200,
    marginTop: 20,
  },
  simpleChart: {
    flexDirection: 'row',
    height: '100%',
    alignItems: 'flex-end',
    gap: 2,
  },
  chartBar: {
    flex: 1,
    backgroundColor: '#007AFF',
    minHeight: 1,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\artists-advanced-search.tsx ---
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, Alert } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, orderBy, getDocs, doc, getDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import { UserRating } from '../src/components/UserRating';
import type { User, ArtistProfile } from '../src/types';

interface ArtistWithProfile extends User {
  profile: ArtistProfile;
}

export default function ArtistsAdvancedSearchScreen() {
  const [styles, setStyles] = useState('');
  const [minRating, setMinRating] = useState('');
  const [location, setLocation] = useState('');
  const [radius, setRadius] = useState('');
  const [artists, setArtists] = useState<ArtistWithProfile[]>([]);
  const [loading, setLoading] = useState(false);
  const [user, setUser] = useState<User | null>(null);
  const [sortBy, setSortBy] = useState<'rating' | 'distance'>('rating');

  useEffect(() => {
    loadUser();
  }, []);

  const loadUser = async () => {
    if (!auth.currentUser) return;

    try {
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }
    } catch (error) {
      console.error('Error loading user:', error);
    }
  };

  const handleSearch = async () => {
    if (!auth.currentUser) return;

    setLoading(true);
    try {
      let baseQuery = query(
        collection(db, 'users'),
        where('role', '==', 'artist')
      );

      // Get all artists first
      const artistsSnapshot = await getDocs(baseQuery);
      let artistsList: ArtistWithProfile[] = [];

      // Get profiles and apply filters
      for (const artistDoc of artistsSnapshot.docs) {
        const artistData = artistDoc.data() as User;
        const profileDoc = await getDoc(doc(db, 'artistProfiles', artistDoc.id));
        
        if (profileDoc.exists()) {
          const profileData = profileDoc.data() as ArtistProfile;

          // Apply style filter
          if (styles) {
            const stylesList = styles.split(',').map(s => s.trim());
            if (!stylesList.some(style => profileData.genres.includes(style))) {
              continue;
            }
          }

          // Apply rating filter for paid users
          if (user?.planId === 'paid' && minRating) {
            if ((artistData.rating || 0) < Number(minRating)) {
              continue;
            }
          }

          // Apply location filter for paid users
          if (user?.planId === 'paid' && location && radius) {
            // In a real app, we would use geolocation here
            // For now, we'll just filter by exact location match
            if (!profileData.mainCity.toLowerCase().includes(location.toLowerCase())) {
              continue;
            }
          }

          artistsList.push({
            ...artistData,
            profile: profileData,
          });
        }
      }

      // Apply sorting
      switch (sortBy) {
        case 'rating':
          artistsList.sort((a, b) => (b.rating || 0) - (a.rating || 0));
          break;
        case 'distance':
          // In a real app, we would sort by actual distance
          // For now, we'll just sort alphabetically by location
          artistsList.sort((a, b) => 
            a.profile.mainCity.localeCompare(b.profile.mainCity)
          );
          break;
      }

      setArtists(artistsList);
    } catch (error) {
      console.error('Error searching artists:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="search" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('search.artists.title')}</Text>
        </View>

        <View style={styles.form}>
          <Text style={styles.label}>{i18n.t('search.styles')}</Text>
          <TextInput
            style={styles.input}
            value={styles}
            onChangeText={setStyles}
            placeholder="Rock, Pop, Jazz"
          />

          {user?.planId === 'paid' && (
            <>
              <Text style={styles.label}>{i18n.t('search.location')}</Text>
              <TextInput
                style={styles.input}
                value={location}
                onChangeText={setLocation}
                placeholder={i18n.t('search.locationPlaceholder')}
              />

              <Text style={styles.label}>{i18n.t('search.radius')}</Text>
              <TextInput
                style={styles.input}
                value={radius}
                onChangeText={setRadius}
                keyboardType="numeric"
                placeholder="km"
              />

              <Text style={styles.label}>{i18n.t('search.minRating')}</Text>
              <TextInput
                style={styles.input}
                value={minRating}
                onChangeText={setMinRating}
                keyboardType="numeric"
                placeholder="1-5"
              />
            </>
          )}

          <View style={styles.sortContainer}>
            <Text style={styles.label}>{i18n.t('search.sortBy')}</Text>
            <View style={styles.sortButtons}>
              <Button
                title={i18n.t('search.sortRating')}
                onPress={() => setSortBy('rating')}
                variant={sortBy === 'rating' ? 'primary' : 'secondary'}
              />
              {user?.planId === 'paid' && (
                <Button
                  title={i18n.t('search.sortDistance')}
                  onPress={() => setSortBy('distance')}
                  variant={sortBy === 'distance' ? 'primary' : 'secondary'}
                />
              )}
            </View>
          </View>

          <Button
            title={i18n.t('search.submit')}
            onPress={handleSearch}
            disabled={loading}
          />
        </View>

        {artists.map((artist) => (
          <View key={artist.id} style={styles.artistCard}>
            <View style={styles.artistHeader}>
              <Text style={styles.artistName}>{artist.email}</Text>
              <UserRating rating={artist.rating || 0} reviewCount={artist.reviewCount || 0} />
            </View>

            <View style={styles.artistDetails}>
              <Text style={styles.detailText}>
                <Ionicons name="location" size={16} /> {artist.profile.mainCity}
              </Text>
              <Text style={styles.detailText}>
                <Ionicons name="musical-notes" size={16} /> {artist.profile.genres.join(', ')}
              </Text>
              <Text style={styles.cacheText}>
                {i18n.t('search.cache')}: {artist.profile.minimumCache}
                {artist.profile.maximumCache > artist.profile.minimumCache && 
                  ` - ${artist.profile.maximumCache}`}
              </Text>
            </View>

            <Text style={styles.description}>
              {artist.profile.description}
            </Text>
          </View>
        ))}

        {!loading && artists.length === 0 && (
          <Text style={styles.emptyText}>
            {i18n.t('search.noResults')}
          </Text>
        )}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  form: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  sortContainer: {
    marginBottom: 15,
  },
  sortButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 10,
  },
  artistCard: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  artistHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  artistName: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  artistDetails: {
    marginBottom: 10,
  },
  detailText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  cacheText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  description: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 16,
    color: '#666',
    marginTop: 20,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\auto-offer-settings.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert, TextInput } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { doc, getDoc, updateDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { User } from '../src/types';

export default function AutoOfferSettingsScreen() {
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<User | null>(null);
  const [enabled, setEnabled] = useState(false);
  const [minCache, setMinCache] = useState('');
  const [genresInput, setGenresInput] = useState('');

  useEffect(() => {
    loadSettings();
  }, []);

  const loadSettings = async () => {
    if (!auth.currentUser) return;

    try {
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        setUser(userData);
        
        if (userData.autoOffer) {
          setEnabled(userData.autoOffer.enabled);
          setMinCache(userData.autoOffer.minCache.toString());
          setGenresInput(userData.autoOffer.genres.join(', '));
        }
      }
    } catch (error) {
      console.error('Error loading settings:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    if (!auth.currentUser) return;

    try {
      const genres = genresInput.split(',').map(g => g.trim()).filter(Boolean);
      
      if (user?.planId === 'free' && genres.length > 3) {
        Alert.alert(i18n.t('autoOffer.error.genresLimit'));
        return;
      }

      await updateDoc(doc(db, 'users', auth.currentUser.uid), {
        autoOffer: {
          enabled,
          minCache: Number(minCache) || 0,
          genres,
          updatedAt: new Date(),
        },
      });

      Alert.alert(i18n.t('autoOffer.success.saved'));
      loadSettings();
    } catch (error) {
      console.error('Error saving settings:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="flash" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('autoOffer.title')}</Text>
        </View>

        <View style={styles.form}>
          <View style={styles.switchContainer}>
            <Text style={styles.label}>{i18n.t('autoOffer.enable')}</Text>
            <Button
              title={enabled ? i18n.t('common.button.enabled') : i18n.t('common.button.disabled')}
              onPress={() => setEnabled(!enabled)}
              variant={enabled ? 'primary' : 'secondary'}
            />
          </View>

          <Text style={styles.label}>{i18n.t('autoOffer.minCache')}</Text>
          <TextInput
            style={styles.input}
            value={minCache}
            onChangeText={setMinCache}
            keyboardType="numeric"
            editable={enabled}
          />

          <Text style={styles.label}>
            {i18n.t('autoOffer.genres')}
            {user?.planId === 'free' && (
              <Text style={styles.planLimit}> (máx. 3)</Text>
            )}
          </Text>
          <TextInput
            style={styles.input}
            value={genresInput}
            onChangeText={setGenresInput}
            placeholder="Rock, Pop, Jazz"
            editable={enabled}
          />

          <Text style={styles.description}>
            {i18n.t('autoOffer.description')}
          </Text>

          <Button
            title={i18n.t('common.button.save')}
            onPress={handleSave}
          />
        </View>
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  form: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  planLimit: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  description: {
    fontSize: 14,
    color: '#666',
    marginBottom: 20,
    fontStyle: 'italic',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\auto-promote-settings.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { doc, getDoc, updateDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { User } from '../src/types';

export default function AutoPromoteSettingsScreen() {
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<User | null>(null);
  const [enabled, setEnabled] = useState(false);

  useEffect(() => {
    loadSettings();
  }, []);

  const loadSettings = async () => {
    if (!auth.currentUser) return;

    try {
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        setUser(userData);
        
        if (userData.autoPromote) {
          setEnabled(userData.autoPromote.enabled);
        }
      }
    } catch (error) {
      console.error('Error loading settings:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    if (!auth.currentUser) return;

    try {
      await updateDoc(doc(db, 'users', auth.currentUser.uid), {
        autoPromote: {
          enabled,
          updatedAt: new Date(),
        },
      });

      Alert.alert(i18n.t('autoPromote.success.saved'));
      loadSettings();
    } catch (error) {
      console.error('Error saving settings:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="megaphone" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('autoPromote.title')}</Text>
        </View>

        <View style={styles.form}>
          <View style={styles.switchContainer}>
            <Text style={styles.label}>{i18n.t('autoPromote.enable')}</Text>
            <Button
              title={enabled ? i18n.t('common.button.enabled') : i18n.t('common.button.disabled')}
              onPress={() => setEnabled(!enabled)}
              variant={enabled ? 'primary' : 'secondary'}
            />
          </View>

          <Text style={styles.description}>
            {i18n.t('autoPromote.description')}
          </Text>

          {user?.planId === 'free' && (
            <Text style={styles.planWarning}>
              {i18n.t('autoPromote.freeWarning')}
            </Text>
          )}

          <Button
            title={i18n.t('common.button.save')}
            onPress={handleSave}
          />
        </View>
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  form: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  description: {
    fontSize: 14,
    color: '#666',
    marginBottom: 20,
    fontStyle: 'italic',
  },
  planWarning: {
    fontSize: 14,
    color: '#FFA000',
    marginBottom: 20,
    fontStyle: 'italic',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\chats.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { Layout } from '../src/components/Layout';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, orderBy, getDocs } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { Chat, User } from '../src/types';

export default function ChatsScreen() {
  const [chats, setChats] = useState<(Chat & { otherUser: User })[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadChats();
  }, []);

  const loadChats = async () => {
    if (!auth.currentUser) return;

    try {
      const chatsSnapshot = await getDocs(query(
        collection(db, 'chats'),
        where('participants', 'array-contains', auth.currentUser.uid),
        orderBy('createdAt', 'desc')
      ));

      const chatsWithUsers = await Promise.all(
        chatsSnapshot.docs.map(async (doc) => {
          const chatData = { id: doc.id, ...doc.data() } as Chat;
          const otherUserId = chatData.participants.find(id => id !== auth.currentUser?.uid);
          
          if (otherUserId) {
            const userDoc = await getDocs(query(
              collection(db, 'users'),
              where('id', '==', otherUserId)
            ));

            if (!userDoc.empty) {
              return {
                ...chatData,
                otherUser: userDoc.docs[0].data() as User,
              };
            }
          }
          
          return null;
        })
      );

      setChats(chatsWithUsers.filter(Boolean) as (Chat & { otherUser: User })[]);
    } catch (error) {
      console.error('Error loading chats:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleOpenChat = (chatId: string) => {
    router.push(`/chat/${chatId}`);
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="chatbubbles" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('chats.title')}</Text>
        </View>

        {chats.map((chat) => (
          <TouchableOpacity
            key={chat.id}
            style={styles.chatItem}
            onPress={() => handleOpenChat(chat.id)}
          >
            <View style={styles.chatHeader}>
              <Text style={styles.userName}>{chat.otherUser.email}</Text>
              {chat.lastMessage && (
                <Text style={styles.lastMessageTime}>
                  {chat.lastMessage.createdAt.toLocaleDateString()}
                </Text>
              )}
            </View>

            {chat.lastMessage && (
              <Text style={styles.lastMessageText} numberOfLines={1}>
                {chat.lastMessage.text}
              </Text>
            )}
          </TouchableOpacity>
        ))}

        {!loading && chats.length === 0 && (
          <Text style={styles.emptyText}>
            {i18n.t('chats.empty')}
          </Text>
        )}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  chatItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  chatHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 5,
  },
  userName: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  lastMessageTime: {
    fontSize: 12,
    color: '#666',
  },
  lastMessageText: {
    fontSize: 14,
    color: '#666',
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 16,
    color: '#666',
    marginTop: 20,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\contractor-dashboard.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Platform } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, getDocs, doc, getDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import { format, subDays, isWithinInterval, startOfDay, endOfDay } from 'date-fns';
import i18n from '../src/i18n';
import type { User, Event, Media } from '../src/types';

// Import Chart.js components only on web platform
let Line: any;
let Pie: any;
if (Platform.OS === 'web') {
  const { Line: WebLine, Pie: WebPie } = require('react-chartjs-2');
  const { Chart, registerables } = require('chart.js');
  Chart.register(...registerables);
  Line = WebLine;
  Pie = WebPie;
}

type Period = '7d' | '30d' | 'custom';
type ChartData = { dates: string[]; values: number[] };
type PieChartData = { labels: string[]; values: number[] };

export default function ContractorDashboardScreen() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [period, setPeriod] = useState<Period>('7d');
  
  const [eventsData, setEventsData] = useState<{
    total: number;
    open: number;
    closed: number;
    canceled: number;
    completed: number;
    chart: ChartData;
    statusChart: PieChartData;
  }>({
    total: 0,
    open: 0,
    closed: 0,
    canceled: 0,
    completed: 0,
    chart: { dates: [], values: [] },
    statusChart: { labels: [], values: [] },
  });

  const [candidaciesData, setCandidaciesData] = useState<{
    total: number;
    approved: number;
    rejected: number;
    pending: number;
    averagePerEvent: number;
    chart: ChartData;
  }>({
    total: 0,
    approved: 0,
    rejected: 0,
    pending: 0,
    averagePerEvent: 0,
    chart: { dates: [], values: [] },
  });

  const [portfolioData, setPortfolioData] = useState<{
    totalViews: number;
    chart: ChartData;
  }>({
    totalViews: 0,
    chart: { dates: [], values: [] },
  });

  const [ratingData, setRatingData] = useState<{
    average: number;
    total: number;
    recent: number;
  }>({
    average: 0,
    total: 0,
    recent: 0,
  });

  useEffect(() => {
    loadDashboard();
  }, [period]);

  const loadDashboard = async () => {
    if (!auth.currentUser) return;

    try {
      // Load user data
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }

      const periodDays = period === '7d' ? 7 : 30;
      const startDate = subDays(new Date(), periodDays);

      // Generate dates array for charts
      const dates = Array.from({ length: periodDays }, (_, i) => {
        const date = subDays(new Date(), i);
        return format(date, 'yyyy-MM-dd');
      }).reverse();

      // Load events
      const eventsSnapshot = await getDocs(query(
        collection(db, 'events'),
        where('creatorId', '==', auth.currentUser.uid)
      ));

      const events = eventsSnapshot.docs.map(doc => ({
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
      })) as Event[];

      const recentEvents = events.filter(e => 
        isWithinInterval(e.createdAt, {
          start: startOfDay(startDate),
          end: endOfDay(new Date()),
        })
      );

      // Calculate events per day
      const eventsPerDay = dates.map(date => {
        return recentEvents.filter(e => 
          format(e.createdAt, 'yyyy-MM-dd') === date
        ).length;
      });

      // Calculate status distribution
      const statusCounts = {
        ABERTO: events.filter(e => e.status === 'ABERTO').length,
        ENCERRADO: events.filter(e => e.status === 'ENCERRADO').length,
        CANCELADO: events.filter(e => e.status === 'CANCELADO').length,
        CONCLUIDO: events.filter(e => e.status === 'CONCLUIDO').length,
      };

      setEventsData({
        total: events.length,
        open: statusCounts.ABERTO,
        closed: statusCounts.ENCERRADO,
        canceled: statusCounts.CANCELADO,
        completed: statusCounts.CONCLUIDO,
        chart: {
          dates,
          values: eventsPerDay,
        },
        statusChart: {
          labels: Object.keys(statusCounts),
          values: Object.values(statusCounts),
        },
      });

      // Load candidacies for all events
      const candidaciesPromises = events.map(event =>
        getDocs(query(
          collection(db, 'candidacies'),
          where('eventId', '==', event.id)
        ))
      );

      const candidaciesSnapshots = await Promise.all(candidaciesPromises);
      const allCandidacies = candidaciesSnapshots.flatMap(snapshot =>
        snapshot.docs.map(doc => ({
          ...doc.data(),
          createdAt: doc.data().createdAt.toDate(),
        }))
      );

      const recentCandidacies = allCandidacies.filter(c =>
        isWithinInterval(c.createdAt, {
          start: startOfDay(startDate),
          end: endOfDay(new Date()),
        })
      );

      // Calculate candidacies per day
      const candidaciesPerDay = dates.map(date => {
        return recentCandidacies.filter(c =>
          format(c.createdAt, 'yyyy-MM-dd') === date
        ).length;
      });

      setCandidaciesData({
        total: allCandidacies.length,
        approved: allCandidacies.filter(c => c.status === 'APROVADA').length,
        rejected: allCandidacies.filter(c => c.status === 'REJEITADA').length,
        pending: allCandidacies.filter(c => c.status === 'PENDENTE').length,
        averagePerEvent: events.length > 0 ? allCandidacies.length / events.length : 0,
        chart: {
          dates,
          values: candidaciesPerDay,
        },
      });

      // Load portfolio data if available
      const mediaSnapshot = await getDocs(query(
        collection(db, 'media'),
        where('userId', '==', auth.currentUser.uid)
      ));

      const media = mediaSnapshot.docs.map(doc => doc.data()) as Media[];
      const totalViews = media.reduce((sum, m) => sum + (m.viewsCount || 0), 0);

      // Calculate views per day if viewsHistory exists
      const viewsPerDay = dates.map(date => {
        return media.reduce((sum, m) => {
          if (m.viewsHistory && m.viewsHistory[date]) {
            return sum + m.viewsHistory[date];
          }
          return sum;
        }, 0);
      });

      setPortfolioData({
        totalViews,
        chart: {
          dates,
          values: viewsPerDay,
        },
      });

      // Load rating data
      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        const reviewsSnapshot = await getDocs(query(
          collection(db, 'reviews'),
          where('reviewedId', '==', auth.currentUser.uid)
        ));

        const reviews = reviewsSnapshot.docs.map(doc => ({
          ...doc.data(),
          createdAt: doc.data().createdAt.toDate(),
        }));

        const recentReviews = reviews.filter(r =>
          isWithinInterval(r.createdAt, {
            start: startOfDay(startDate),
            end: endOfDay(new Date()),
          })
        );

        setRatingData({
          average: userData.rating || 0,
          total: userData.reviewCount || 0,
          recent: recentReviews.length,
        });
      }
    } catch (error) {
      console.error('Error loading dashboard:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderLineChart = (data: ChartData, label: string, color: string) => {
    if (Platform.OS !== 'web') {
      return (
        <View style={styles.simpleChart}>
          {data.values.map((value, index) => (
            <View
              key={index}
              style={[
                styles.chartBar,
                {
                  height: `${(value / Math.max(...data.values)) * 100}%`,
                  backgroundColor: color,
                },
              ]}
            />
          ))}
        </View>
      );
    }

    return (
      <Line
        data={{
          labels: data.dates.map(date => format(new Date(date), 'dd/MM')),
          datasets: [
            {
              label,
              data: data.values,
              fill: false,
              borderColor: color,
              tension: 0.1,
            },
          ],
        }}
        options={{
          responsive: true,
          plugins: {
            legend: {
              position: 'top' as const,
            },
          },
          scales: {
            y: {
              beginAtZero: true,
            },
          },
        }}
      />
    );
  };

  const renderPieChart = (data: PieChartData) => {
    if (Platform.OS !== 'web') {
      return (
        <View style={styles.simplePieChart}>
          {data.values.map((value, index) => (
            <View
              key={index}
              style={[
                styles.pieSlice,
                {
                  flex: value,
                  backgroundColor: [
                    '#4CAF50',
                    '#FFC107',
                    '#F44336',
                    '#2196F3',
                  ][index],
                },
              ]}
            />
          ))}
        </View>
      );
    }

    return (
      <Pie
        data={{
          labels: data.labels.map(label => i18n.t(`dashboard.contractor.status.${label.toLowerCase()}`)),
          datasets: [
            {
              data: data.values,
              backgroundColor: [
                '#4CAF50',
                '#FFC107',
                '#F44336',
                '#2196F3',
              ],
            },
          ],
        }}
        options={{
          responsive: true,
          plugins: {
            legend: {
              position: 'right' as const,
            },
          },
        }}
      />
    );
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="stats-chart" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('dashboard.contractor.title')}</Text>
        </View>

        <View style={styles.periodSelector}>
          <Button
            title="7 dias"
            onPress={() => setPeriod('7d')}
            variant={period === '7d' ? 'primary' : 'secondary'}
          />
          <Button
            title="30 dias"
            onPress={() => setPeriod('30d')}
            variant={period === '30d' ? 'primary' : 'secondary'}
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{i18n.t('dashboard.contractor.events')}</Text>
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{eventsData.total}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.totalEvents')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#4CAF50' }]}>{eventsData.open}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.openEvents')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#2196F3' }]}>{eventsData.completed}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.completedEvents')}</Text>
            </View>
          </View>
          <View style={styles.chart}>
            {renderLineChart(
              eventsData.chart,
              i18n.t('dashboard.contractor.eventsChart'),
              '#007AFF'
            )}
          </View>
          <View style={[styles.chart, styles.pieChart]}>
            {renderPieChart(eventsData.statusChart)}
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{i18n.t('dashboard.contractor.candidacies')}</Text>
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{candidaciesData.total}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.totalCandidacies')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#4CAF50' }]}>
                {candidaciesData.averagePerEvent.toFixed(1)}
              </Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.averagePerEvent')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#FFC107' }]}>{candidaciesData.pending}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.pendingCandidacies')}</Text>
            </View>
          </View>
          <View style={styles.chart}>
            {renderLineChart(
              candidaciesData.chart,
              i18n.t('dashboard.contractor.candidaciesChart'),
              '#4CAF50'
            )}
          </View>
        </View>

        {user?.planId === 'paid' && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>{i18n.t('dashboard.contractor.portfolio')}</Text>
            <View style={styles.statsGrid}>
              <View style={styles.statCard}>
                <Text style={styles.statValue}>{portfolioData.totalViews}</Text>
                <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.totalViews')}</Text>
              </View>
            </View>
            <View style={styles.chart}>
              {renderLineChart(
                portfolioData.chart,
                i18n.t('dashboard.contractor.viewsChart'),
                '#FF9800'
              )}
            </View>
          </View>
        )}

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{i18n.t('dashboard.contractor.rating')}</Text>
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{ratingData.average.toFixed(1)}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.averageRating')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{ratingData.total}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.totalReviews')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{ratingData.recent}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.contractor.recentReviews')}</Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  periodSelector: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 10,
    marginBottom: 20,
  },
  section: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  statCard: {
    width: '31%',
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    padding: 15,
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#007AFF',
    marginBottom: 5,
  },
  statLabel: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
  },
  chart: {
    height: 200,
    marginTop: 20,
  },
  pieChart: {
    marginTop: 40,
  },
  simpleChart: {
    flexDirection: 'row',
    height: '100%',
    alignItems: 'flex-end',
    gap: 2,
  },
  chartBar: {
    flex: 1,
    backgroundColor: '#007AFF',
    minHeight: 1,
  },
  simplePieChart: {
    flexDirection: 'row',
    height: '100%',
  },
  pieSlice: {
    height: '100%',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\dashboard.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, ActivityIndicator } from 'react-native';
import { Layout } from '../src/components/Layout';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, getDocs, doc, getDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import { LineChart } from '../src/components/LineChart';
import type { User, Event, Candidacy, Media } from '../src/types';

interface DashboardData {
  eventsCount: number;
  candidaciesCount: number;
  portfolioViews: number;
  rating: number;
  dailyStats?: {
    dates: string[];
    events: number[];
    candidacies: number[];
    views: number[];
  };
}

export default function DashboardScreen() {
  const [data, setData] = useState<DashboardData | null>(null);
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    loadDashboard();
  }, []);

  const loadDashboard = async () => {
    if (!auth.currentUser) return;

    try {
      // Load user data
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }

      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      let eventsCount = 0;
      let candidaciesCount = 0;
      let portfolioViews = 0;
      let dailyStats: DashboardData['dailyStats'] | undefined;

      if (userDoc.data().role === 'contractor') {
        // Load contractor events
        const eventsQuery = query(
          collection(db, 'events'),
          where('creatorId', '==', auth.currentUser.uid),
          where('status', '!=', 'CANCELADO'),
          where('createdAt', '>=', thirtyDaysAgo)
        );
        const eventsSnapshot = await getDocs(eventsQuery);
        eventsCount = eventsSnapshot.docs.length;

        if (userDoc.data().planId === 'paid') {
          // Calculate daily stats for paid users
          const dates = new Array(30).fill(0).map((_, i) => {
            const date = new Date();
            date.setDate(date.getDate() - i);
            return date.toISOString().split('T')[0];
          }).reverse();

          const events = new Array(30).fill(0);
          eventsSnapshot.docs.forEach(doc => {
            const eventDate = new Date(doc.data().createdAt.toDate())
              .toISOString()
              .split('T')[0];
            const index = dates.indexOf(eventDate);
            if (index !== -1) {
              events[index]++;
            }
          });

          dailyStats = {
            dates,
            events,
            candidacies: new Array(30).fill(0),
            views: new Array(30).fill(0),
          };
        }
      } else {
        // Load artist candidacies
        const candidaciesQuery = query(
          collection(db, 'candidacies'),
          where('artistId', '==', auth.currentUser.uid),
          where('status', 'in', ['PENDENTE', 'APROVADA']),
          where('createdAt', '>=', thirtyDaysAgo)
        );
        const candidaciesSnapshot = await getDocs(candidaciesQuery);
        candidaciesCount = candidaciesSnapshot.docs.length;

        if (userDoc.data().planId === 'paid') {
          // Calculate daily stats for paid users
          const dates = new Array(30).fill(0).map((_, i) => {
            const date = new Date();
            date.setDate(date.getDate() - i);
            return date.toISOString().split('T')[0];
          }).reverse();

          const candidacies = new Array(30).fill(0);
          candidaciesSnapshot.docs.forEach(doc => {
            const candidacyDate = new Date(doc.data().createdAt.toDate())
              .toISOString()
              .split('T')[0];
            const index = dates.indexOf(candidacyDate);
            if (index !== -1) {
              candidacies[index]++;
            }
          });

          dailyStats = {
            dates,
            events: new Array(30).fill(0),
            candidacies,
            views: new Array(30).fill(0),
          };
        }
      }

      // Load portfolio views
      const mediaQuery = query(
        collection(db, 'media'),
        where('userId', '==', auth.currentUser.uid)
      );
      const mediaSnapshot = await getDocs(mediaQuery);
      portfolioViews = mediaSnapshot.docs.reduce((total, doc) => 
        total + (doc.data().viewsCount || 0), 0
      );

      if (dailyStats) {
        // Calculate daily views for paid users
        mediaSnapshot.docs.forEach(doc => {
          const mediaData = doc.data();
          if (mediaData.viewsHistory) {
            Object.entries(mediaData.viewsHistory).forEach(([date, views]) => {
              const index = dailyStats!.dates.indexOf(date);
              if (index !== -1) {
                dailyStats!.views[index] += views as number;
              }
            });
          }
        });
      }

      setData({
        eventsCount,
        candidaciesCount,
        portfolioViews,
        rating: userDoc.data().rating || 0,
        dailyStats,
      });
    } catch (error) {
      console.error('Error loading dashboard:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <Layout>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#007AFF" />
        </View>
      </Layout>
    );
  }

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="stats-chart" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('dashboard.title')}</Text>
        </View>

        <View style={styles.statsGrid}>
          {user?.role === 'contractor' ? (
            <View style={styles.statCard}>
              <Ionicons name="calendar" size={24} color="#4CAF50" />
              <Text style={styles.statValue}>{data?.eventsCount}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.eventsCreated')}</Text>
            </View>
          ) : (
            <View style={styles.statCard}>
              <Ionicons name="people" size={24} color="#2196F3" />
              <Text style={styles.statValue}>{data?.candidaciesCount}</Text>
              <Text style={styles.statLabel}>{i18n.t('dashboard.candidacies')}</Text>
            </View>
          )}

          <View style={styles.statCard}>
            <Ionicons name="eye" size={24} color="#FF9800" />
            <Text style={styles.statValue}>{data?.portfolioViews}</Text>
            <Text style={styles.statLabel}>{i18n.t('dashboard.portfolioViews')}</Text>
          </View>

          <View style={styles.statCard}>
            <Ionicons name="star" size={24} color="#F44336" />
            <Text style={styles.statValue}>{data?.rating.toFixed(1)}</Text>
            <Text style={styles.statLabel}>{i18n.t('dashboard.rating')}</Text>
          </View>
        </View>

        {user?.planId === 'paid' && data?.dailyStats && (
          <>
            <View style={styles.chartContainer}>
              <Text style={styles.chartTitle}>
                {user.role === 'contractor'
                  ? i18n.t('dashboard.charts.events')
                  : i18n.t('dashboard.charts.candidacies')}
              </Text>
              <LineChart
                data={user.role === 'contractor'
                  ? data.dailyStats.events
                  : data.dailyStats.candidacies}
                labels={data.dailyStats.dates.map(date => date.split('-')[2])}
                color="#4CAF50"
              />
            </View>

            <View style={styles.chartContainer}>
              <Text style={styles.chartTitle}>
                {i18n.t('dashboard.charts.views')}
              </Text>
              <LineChart
                data={data.dailyStats.views}
                labels={data.dailyStats.dates.map(date => date.split('-')[2])}
                color="#FF9800"
              />
            </View>
          </>
        )}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  statCard: {
    width: '48%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    marginVertical: 10,
  },
  statLabel: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
  },
  chartContainer: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  chartTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\edit-artist-profile.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, StyleSheet, Alert, ScrollView, ActivityIndicator } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { doc, getDoc, setDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { ArtistProfile, User } from '../src/types';

export default function EditArtistProfileScreen() {
  const [profile, setProfile] = useState<Partial<ArtistProfile>>({
    minimumCache: 0,
    maximumCache: 0,
    mainCity: '',
    coverageRadius: 0,
    genres: [],
    description: '',
  });
  const [genresInput, setGenresInput] = useState('');
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [userPlan, setUserPlan] = useState<string>('free');

  useEffect(() => {
    loadProfile();
  }, []);

  const loadProfile = async () => {
    if (!auth.currentUser) return;

    try {
      const [profileDoc, userDoc] = await Promise.all([
        getDoc(doc(db, 'artistProfiles', auth.currentUser.uid)),
        getDoc(doc(db, 'users', auth.currentUser.uid))
      ]);

      if (profileDoc.exists()) {
        const profileData = profileDoc.data() as ArtistProfile;
        setProfile(profileData);
        setGenresInput(profileData.genres.join(', '));
      }

      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        setUserPlan(userData.planId);
      }
    } catch (error) {
      console.error('Erro ao carregar perfil:', error);
      Alert.alert('Erro', i18n.t('common.error.profile'));
    } finally {
      setLoading(false);
    }
  };

  const validateProfile = () => {
    if (profile.minimumCache! > profile.maximumCache!) {
      Alert.alert('Erro', 'O cachê mínimo não pode ser maior que o máximo');
      return false;
    }

    if (profile.coverageRadius! < 0) {
      setProfile(prev => ({ ...prev, coverageRadius: 0 }));
    }

    const genres = genresInput.split(',').map(g => g.trim()).filter(Boolean);
    if (userPlan === 'free' && genres.length > 3) {
      Alert.alert('Erro', 'Plano gratuito permite apenas 3 gêneros musicais');
      return false;
    }

    return true;
  };

  const handleSave = async () => {
    if (!auth.currentUser || !validateProfile()) return;

    setSaving(true);
    try {
      const genres = genresInput.split(',').map(g => g.trim()).filter(Boolean);
      const updatedProfile = {
        ...profile,
        genres,
        coverageRadius: userPlan === 'free' ? 0 : profile.coverageRadius,
        userId: auth.currentUser.uid,
        updatedAt: new Date(),
      };

      await setDoc(doc(db, 'artistProfiles', auth.currentUser.uid), updatedProfile);
      Alert.alert('Sucesso', i18n.t('common.success.profileSaved'));
      router.back();
    } catch (error) {
      Alert.alert('Erro', i18n.t('common.error.profile'));
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007AFF" />
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
      <ScrollView style={styles.scrollView}>
        <View style={styles.header}>
          <Ionicons name="person" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('profile.artist.title')}</Text>
        </View>

        <View style={styles.form}>
          <Text style={styles.label}>{i18n.t('profile.artist.minimumCache')}</Text>
          <TextInput
            style={styles.input}
            value={profile.minimumCache?.toString()}
            onChangeText={(value) => setProfile({ ...profile, minimumCache: Number(value) || 0 })}
            keyboardType="numeric"
          />

          <Text style={styles.label}>{i18n.t('profile.artist.maximumCache')}</Text>
          <TextInput
            style={styles.input}
            value={profile.maximumCache?.toString()}
            onChangeText={(value) => setProfile({ ...profile, maximumCache: Number(value) || 0 })}
            keyboardType="numeric"
          />

          <Text style={styles.label}>{i18n.t('profile.artist.mainCity')}</Text>
          <TextInput
            style={styles.input}
            value={profile.mainCity}
            onChangeText={(value) => setProfile({ ...profile, mainCity: value })}
          />

          {userPlan !== 'free' && (
            <>
              <Text style={styles.label}>{i18n.t('profile.artist.coverageRadius')}</Text>
              <TextInput
                style={styles.input}
                value={profile.coverageRadius?.toString()}
                onChangeText={(value) => setProfile({ ...profile, coverageRadius: Number(value) || 0 })}
                keyboardType="numeric"
              />
            </>
          )}

          <Text style={styles.label}>
            {i18n.t('profile.artist.genres')}
            {userPlan === 'free' && (
              <Text style={styles.planLimit}> (máx. 3)</Text>
            )}
          </Text>
          <TextInput
            style={styles.input}
            value={genresInput}
            onChangeText={setGenresInput}
            placeholder="Rock, Pop, Jazz"
          />

          <Text style={styles.label}>{i18n.t('profile.artist.description')}</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={profile.description}
            onChangeText={(value) => setProfile({ ...profile, description: value })}
            multiline
            numberOfLines={4}
          />
        </View>

        <Button 
          title={i18n.t('common.button.save')} 
          onPress={handleSave}
          disabled={saving}
        />
        
        {saving && (
          <View style={styles.savingContainer}>
            <ActivityIndicator size="small" color="#007AFF" />
          </View>
        )}
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollView: {
    flex: 1,
    padding: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: 30,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
    textAlign: 'center',
  },
  form: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  planLimit: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  savingContainer: {
    marginTop: 10,
    alignItems: 'center',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\edit-contractor-profile.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, StyleSheet, Alert, ScrollView, ActivityIndicator } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { doc, getDoc, setDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { ContractorProfile, User } from '../src/types';

export default function EditContractorProfileScreen() {
  const [profile, setProfile] = useState<Partial<ContractorProfile>>({
    mainAddress: '',
    venueCapacity: 0,
    description: '',
    eventTypes: [],
  });
  const [eventTypesInput, setEventTypesInput] = useState('');
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [userPlan, setUserPlan] = useState<string>('free');

  useEffect(() => {
    loadProfile();
  }, []);

  const loadProfile = async () => {
    if (!auth.currentUser) return;

    try {
      const [profileDoc, userDoc] = await Promise.all([
        getDoc(doc(db, 'contractorProfiles', auth.currentUser.uid)),
        getDoc(doc(db, 'users', auth.currentUser.uid))
      ]);

      if (profileDoc.exists()) {
        const profileData = profileDoc.data() as ContractorProfile;
        setProfile(profileData);
        setEventTypesInput(profileData.eventTypes.join(', '));
      }

      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        setUserPlan(userData.planId);
      }
    } catch (error) {
      console.error('Erro ao carregar perfil:', error);
      Alert.alert('Erro', i18n.t('common.error.profile'));
    } finally {
      setLoading(false);
    }
  };

  const validateProfile = () => {
    if (profile.venueCapacity! < 1) {
      Alert.alert('Erro', 'A capacidade do local deve ser maior que zero');
      return false;
    }

    const eventTypes = eventTypesInput.split(',').map(t => t.trim()).filter(Boolean);
    if (userPlan === 'free' && eventTypes.length > 2) {
      Alert.alert('Erro', 'Plano gratuito permite apenas 2 tipos de evento');
      return false;
    }

    return true;
  };

  const handleSave = async () => {
    if (!auth.currentUser || !validateProfile()) return;

    setSaving(true);
    try {
      const eventTypes = eventTypesInput.split(',').map(t => t.trim()).filter(Boolean);
      const updatedProfile = {
        ...profile,
        eventTypes,
        userId: auth.currentUser.uid,
        updatedAt: new Date(),
      };

      await setDoc(doc(db, 'contractorProfiles', auth.currentUser.uid), updatedProfile);
      Alert.alert('Sucesso', i18n.t('common.success.profileSaved'));
      router.back();
    } catch (error) {
      Alert.alert('Erro', i18n.t('common.error.profile'));
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007AFF" />
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
      <ScrollView style={styles.scrollView}>
        <View style={styles.header}>
          <Ionicons name="business" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('profile.contractor.title')}</Text>
        </View>

        <View style={styles.form}>
          <Text style={styles.label}>{i18n.t('profile.contractor.mainAddress')}</Text>
          <TextInput
            style={styles.input}
            value={profile.mainAddress}
            onChangeText={(value) => setProfile({ ...profile, mainAddress: value })}
          />

          <Text style={styles.label}>{i18n.t('profile.contractor.venueCapacity')}</Text>
          <TextInput
            style={styles.input}
            value={profile.venueCapacity?.toString()}
            onChangeText={(value) => setProfile({ ...profile, venueCapacity: Number(value) || 0 })}
            keyboardType="numeric"
          />

          <Text style={styles.label}>
            {i18n.t('profile.contractor.eventTypes')}
            {userPlan === 'free' && (
              <Text style={styles.planLimit}> (máx. 2)</Text>
            )}
          </Text>
          <TextInput
            style={styles.input}
            value={eventTypesInput}
            onChangeText={setEventTypesInput}
            placeholder="Casamento, Formatura"
          />

          <Text style={styles.label}>{i18n.t('profile.contractor.description')}</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={profile.description}
            onChangeText={(value) => setProfile({ ...profile, description: value })}
            multiline
            numberOfLines={4}
          />
        </View>

        <Button 
          title={i18n.t('common.button.save')} 
          onPress={handleSave}
          disabled={saving}
        />
        
        {saving && (
          <View style={styles.savingContainer}>
            <ActivityIndicator size="small" color="#007AFF" />
          </View>
        )}
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollView: {
    flex: 1,
    padding: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: 30,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
    textAlign: 'center',
  },
  form: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  planLimit: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  savingContainer: {
    marginTop: 10,
    alignItems: 'center',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\events-advanced-search.tsx ---
import React, { useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, Alert } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, orderBy, getDocs } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import { EventList } from '../src/components/EventList';
import type { Event, User } from '../src/types';

export default function EventsAdvancedSearchScreen() {
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');
  const [styles, setStyles] = useState('');
  const [location, setLocation] = useState('');
  const [radius, setRadius] = useState('');
  const [minRating, setMinRating] = useState('');
  const [minCache, setMinCache] = useState('');
  const [maxCache, setMaxCache] = useState('');
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(false);
  const [user, setUser] = useState<User | null>(null);
  const [sortBy, setSortBy] = useState<'date' | 'rating' | 'distance'>('date');

  useEffect(() => {
    loadUser();
  }, []);

  const loadUser = async () => {
    if (!auth.currentUser) return;

    try {
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }
    } catch (error) {
      console.error('Error loading user:', error);
    }
  };

  const handleSearch = async () => {
    if (!auth.currentUser) return;

    setLoading(true);
    try {
      let baseQuery = query(collection(db, 'events'), where('status', '==', 'ABERTO'));

      // Add date filters
      if (startDate && endDate) {
        baseQuery = query(baseQuery, 
          where('startDate', '>=', new Date(startDate)),
          where('endDate', '<=', new Date(endDate))
        );
      }

      // Add style filter
      if (styles) {
        const stylesList = styles.split(',').map(s => s.trim());
        baseQuery = query(baseQuery, where('styles', 'array-contains-any', stylesList));
      }

      // Add cache range filter for paid users
      if (user?.planId === 'paid' && minCache && maxCache) {
        baseQuery = query(baseQuery,
          where('minCache', '>=', Number(minCache)),
          where('maxCache', '<=', Number(maxCache))
        );
      }

      // Execute query
      const eventsSnapshot = await getDocs(baseQuery);
      let eventsList = eventsSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as Event[];

      // Apply client-side filters for paid users
      if (user?.planId === 'paid') {
        // Filter by rating
        if (minRating) {
          eventsList = eventsList.filter(event => {
            const rating = event.rating || 0;
            return rating >= Number(minRating);
          });
        }

        // Filter by location radius
        if (location && radius) {
          // In a real app, we would use geolocation here
          // For now, we'll just filter by exact location match
          eventsList = eventsList.filter(event => 
            event.location.toLowerCase().includes(location.toLowerCase())
          );
        }
      }

      // Apply sorting
      switch (sortBy) {
        case 'date':
          eventsList.sort((a, b) => 
            new Date(b.startDate).getTime() - new Date(a.startDate).getTime()
          );
          break;
        case 'rating':
          eventsList.sort((a, b) => (b.rating || 0) - (a.rating || 0));
          break;
        case 'distance':
          // In a real app, we would sort by actual distance
          // For now, we'll just sort alphabetically by location
          eventsList.sort((a, b) => 
            a.location.localeCompare(b.location)
          );
          break;
      }

      setEvents(eventsList);
    } catch (error) {
      console.error('Error searching events:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="search" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('search.title')}</Text>
        </View>

        <View style={styles.form}>
          <Text style={styles.label}>{i18n.t('search.startDate')}</Text>
          <TextInput
            style={styles.input}
            value={startDate}
            onChangeText={setStartDate}
            placeholder="YYYY-MM-DD"
          />

          <Text style={styles.label}>{i18n.t('search.endDate')}</Text>
          <TextInput
            style={styles.input}
            value={endDate}
            onChangeText={setEndDate}
            placeholder="YYYY-MM-DD"
          />

          <Text style={styles.label}>{i18n.t('search.styles')}</Text>
          <TextInput
            style={styles.input}
            value={styles}
            onChangeText={setStyles}
            placeholder="Rock, Pop, Jazz"
          />

          {user?.planId === 'paid' && (
            <>
              <Text style={styles.label}>{i18n.t('search.location')}</Text>
              <TextInput
                style={styles.input}
                value={location}
                onChangeText={setLocation}
                placeholder={i18n.t('search.locationPlaceholder')}
              />

              <Text style={styles.label}>{i18n.t('search.radius')}</Text>
              <TextInput
                style={styles.input}
                value={radius}
                onChangeText={setRadius}
                keyboardType="numeric"
                placeholder="km"
              />

              <Text style={styles.label}>{i18n.t('search.minRating')}</Text>
              <TextInput
                style={styles.input}
                value={minRating}
                onChangeText={setMinRating}
                keyboardType="numeric"
                placeholder="1-5"
              />

              <Text style={styles.label}>{i18n.t('search.cache')}</Text>
              <View style={styles.cacheContainer}>
                <TextInput
                  style={[styles.input, styles.cacheInput]}
                  value={minCache}
                  onChangeText={setMinCache}
                  keyboardType="numeric"
                  placeholder={i18n.t('search.minCache')}
                />
                <TextInput
                  style={[styles.input, styles.cacheInput]}
                  value={maxCache}
                  onChangeText={setMaxCache}
                  keyboardType="numeric"
                  placeholder={i18n.t('search.maxCache')}
                />
              </View>
            </>
          )}

          <View style={styles.sortContainer}>
            <Text style={styles.label}>{i18n.t('search.sortBy')}</Text>
            <View style={styles.sortButtons}>
              <Button
                title={i18n.t('search.sortDate')}
                onPress={() => setSortBy('date')}
                variant={sortBy === 'date' ? 'primary' : 'secondary'}
              />
              <Button
                title={i18n.t('search.sortRating')}
                onPress={() => setSortBy('rating')}
                variant={sortBy === 'rating' ? 'primary' : 'secondary'}
              />
              {user?.planId === 'paid' && (
                <Button
                  title={i18n.t('search.sortDistance')}
                  onPress={() => setSortBy('distance')}
                  variant={sortBy === 'distance' ? 'primary' : 'secondary'}
                />
              )}
            </View>
          </View>

          <Button
            title={i18n.t('search.submit')}
            onPress={handleSearch}
            disabled={loading}
          />
        </View>

        {events.length > 0 && (
          <EventList
            events={events}
            onUpdate={handleSearch}
            isPaidPlan={user?.planId === 'paid'}
          />
        )}

        {!loading && events.length === 0 && (
          <Text style={styles.emptyText}>
            {i18n.t('search.noResults')}
          </Text>
        )}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  form: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  cacheContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 10,
  },
  cacheInput: {
    flex: 1,
  },
  sortContainer: {
    marginBottom: 15,
  },
  sortButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 10,
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 16,
    color: '#666',
    marginTop: 20,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\events-search-artist.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, getDocs, addDoc, doc, getDoc, updateDoc, increment } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { Event, User, ArtistProfile, AvailabilityBlock } from '../src/types';

export default function EventsSearchArtistScreen() {
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<User | null>(null);
  const [profile, setProfile] = useState<ArtistProfile | null>(null);
  const [availabilityBlocks, setAvailabilityBlocks] = useState<AvailabilityBlock[]>([]);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    if (!auth.currentUser) return;

    try {
      const [userDoc, profileDoc, eventsSnapshot, blocksSnapshot] = await Promise.all([
        getDoc(doc(db, 'users', auth.currentUser.uid)),
        getDoc(doc(db, 'artistProfiles', auth.currentUser.uid)),
        getDocs(query(
          collection(db, 'events'),
          where('status', '==', 'ABERTO')
        )),
        getDocs(query(
          collection(db, 'artistAgenda'),
          where('artistId', '==', auth.currentUser.uid)
        ))
      ]);

      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }

      if (profileDoc.exists()) {
        setProfile(profileDoc.data() as ArtistProfile);
      }

      let eventsList = eventsSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as Event[];

      // Filter events by artist's genres if profile exists
      if (profile?.genres.length) {
        eventsList = eventsList.filter(event =>
          event.styles.some(style => profile.genres.includes(style))
        );
      }

      const blocks = blocksSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        startDate: doc.data().startDate.toDate(),
        endDate: doc.data().endDate.toDate(),
      })) as AvailabilityBlock[];

      setAvailabilityBlocks(blocks);
      setEvents(eventsList);
    } catch (error) {
      console.error('Error loading data:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleApply = async (event: Event) => {
    if (!auth.currentUser) return;

    if (user?.planId === 'free' && (user?.credits || 0) < 1) {
      Alert.alert(i18n.t('events.error.noCredits'));
      return;
    }

    try {
      // Check if already applied
      const existingCandidacy = await getDocs(query(
        collection(db, 'candidacies'),
        where('artistId', '==', auth.currentUser.uid),
        where('eventId', '==', event.id)
      ));

      if (!existingCandidacy.empty) {
        Alert.alert(i18n.t('events.error.alreadyApplied'));
        return;
      }

      // Create candidacy
      await addDoc(collection(db, 'candidacies'), {
        artistId: auth.currentUser.uid,
        eventId: event.id,
        status: 'PENDENTE',
        createdAt: new Date(),
      });

      // Deduct credit if free plan
      if (user?.planId === 'free') {
        await updateDoc(doc(db, 'users', auth.currentUser.uid), {
          credits: increment(-1)
        });
      }

      Alert.alert(i18n.t('events.success.applied'));
      loadData(); // Refresh data
    } catch (error) {
      console.error('Error applying to event:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const checkAvailability = (event: Event) => {
    const eventStart = new Date(event.startDate);
    const eventEnd = new Date(event.endDate);

    const conflicts = availabilityBlocks.some(block => {
      return (
        block.status === 'BUSY' &&
        eventStart <= block.endDate &&
        eventEnd >= block.startDate
      );
    });

    return !conflicts;
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="search" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('events.search.title')}</Text>
        </View>

        {events.map((event) => (
          <View key={event.id} style={styles.eventItem}>
            <View style={styles.eventHeader}>
              <Text style={styles.eventTitle}>{event.title}</Text>
              <Text style={styles.eventType}>{event.eventType}</Text>
            </View>

            <View style={styles.eventDetails}>
              <Text style={styles.detailText}>
                <Ionicons name="calendar" size={16} /> {new Date(event.startDate).toLocaleDateString()}
              </Text>
              <Text style={styles.detailText}>
                <Ionicons name="location" size={16} /> {event.location}
              </Text>
              <Text style={styles.detailText}>
                <Ionicons name="musical-notes" size={16} /> {event.styles.join(', ')}
              </Text>
              <Text style={styles.cacheText}>
                {i18n.t('events.cache')}: {event.minCache}
                {event.maxCache > event.minCache && ` - ${event.maxCache}`}
              </Text>
            </View>

            <View style={styles.availabilityInfo}>
              <Ionicons
                name={checkAvailability(event) ? "checkmark-circle" : "close-circle"}
                size={20}
                color={checkAvailability(event) ? "#4CAF50" : "#F44336"}
              />
              <Text style={[
                styles.availabilityText,
                { color: checkAvailability(event) ? "#4CAF50" : "#F44336" }
              ]}>
                {i18n.t(checkAvailability(event) ? 'agenda.available' : 'agenda.unavailable')}
              </Text>
            </View>
            <Button
              title={i18n.t('events.apply')}
              onPress={() => handleApply(event)}
              disabled={!checkAvailability(event)}
            />
          </View>
        ))}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  eventItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  eventHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  eventTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
  },
  eventType: {
    fontSize: 14,
    color: '#666',
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  eventDetails: {
    marginBottom: 15,
  },
  detailText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  cacheText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 5,
  },
  availabilityInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  availabilityText: {
    marginLeft: 5,
    fontSize: 14,
    fontWeight: 'bold',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\home-artist.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { signOut } from 'firebase/auth';
import { router } from 'expo-router';
import { doc, getDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import { Layout } from '../src/components/Layout';
import { Navigation } from '../src/components/Navigation';

export default function HomeArtistScreen() {
  const [hasProfile, setHasProfile] = useState<boolean>(false);

  useEffect(() => {
    checkProfile();
  }, []);

  const checkProfile = async () => {
    if (!auth.currentUser) return;

    try {
      const profileDoc = await getDoc(doc(db, 'artistProfiles', auth.currentUser.uid));
      setHasProfile(profileDoc.exists());
    } catch (error) {
      console.error('Erro ao verificar perfil:', error);
    }
  };

  const handleSignOut = async () => {
    try {
      await signOut(auth);
      router.replace('/login');
    } catch (error) {
      console.error('Erro ao sair:', error);
    }
  };

  return (
    <Layout>
      <View style={styles.header}>
        <Ionicons name="person" size={32} color="#007AFF" />
        <Text style={styles.title}>{i18n.t('screens.homeArtist.title')}</Text>
      </View>
      
      <Text style={styles.subtitle}>{i18n.t('screens.homeArtist.welcome')}</Text>
      
      {!hasProfile && (
        <Button
          title={i18n.t('common.button.completeProfile')}
          onPress={() => router.push('/edit-artist-profile')}
        />
      )}
      
      <Button 
        title={i18n.t('common.button.signOut')} 
        onPress={handleSignOut} 
        variant="secondary" 
      />
      
      <Navigation />
    </Layout>
  );
}

const styles = StyleSheet.create({
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 30,
    textAlign: 'center',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\home-contractor.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { signOut } from 'firebase/auth';
import { router } from 'expo-router';
import { doc, getDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';

export default function HomeContractorScreen() {
  const [hasProfile, setHasProfile] = useState<boolean>(false);

  useEffect(() => {
    checkProfile();
  }, []);

  const checkProfile = async () => {
    if (!auth.currentUser) return;

    try {
      const profileDoc = await getDoc(doc(db, 'contractorProfiles', auth.currentUser.uid));
      setHasProfile(profileDoc.exists());
    } catch (error) {
      console.error('Erro ao verificar perfil:', error);
    }
  };

  const handleSignOut = async () => {
    try {
      await signOut(auth);
      router.replace('/login');
    } catch (error) {
      console.error('Erro ao sair:', error);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Ionicons name="business" size={32} color="#007AFF" />
        <Text style={styles.title}>{i18n.t('screens.homeContractor.title')}</Text>
      </View>
      
      <Text style={styles.subtitle}>{i18n.t('screens.homeContractor.welcome')}</Text>
      
      {!hasProfile && (
        <Button
          title={i18n.t('common.button.completeProfile')}
          onPress={() => router.push('/edit-contractor-profile')}
        />
      )}
      
      <Button title={i18n.t('common.button.signOut')} onPress={handleSignOut} variant="secondary" />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 30,
    textAlign: 'center',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\home.tsx ---
import { HomeScreen } from '../src/screens/HomeScreen';
export default HomeScreen;

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\index.tsx ---
import { Redirect } from 'expo-router';
import { useEffect, useState } from 'react';
import { View, ActivityIndicator } from 'react-native';
import { auth, db } from '../src/services/firebase';
import { doc, getDoc } from 'firebase/firestore';

export default function Index() {
  const [loading, setLoading] = useState(true);
  const [redirectTo, setRedirectTo] = useState<string | null>(null);

  useEffect(() => {
    const checkUser = async () => {
      if (!auth.currentUser) {
        setRedirectTo('/login');
        setLoading(false);
        return;
      }

      try {
        const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
        if (userDoc.exists()) {
          const userData = userDoc.data();
          setRedirectTo(userData.role === 'artist' ? '/home-artist' : '/home-contractor');
        } else {
          setRedirectTo('/login');
        }
      } catch (error) {
        console.error('Error checking user:', error);
        setRedirectTo('/login');
      }
      setLoading(false);
    };

    checkUser();
  }, []);

  if (loading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" />
      </View>
    );
  }

  if (redirectTo) {
    return <Redirect href={redirectTo} />;
  }

  return null;
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\login.tsx ---
import React, { useState } from 'react';
import { View, Text, TextInput, StyleSheet, Alert } from 'react-native';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { signInWithEmailAndPassword } from 'firebase/auth';
import { doc, getDoc, setDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { SafeAreaView } from 'react-native-safe-area-context';
import i18n from '../src/i18n';

export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleLogin = async () => {
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      const user = userCredential.user;

      const userDoc = await getDoc(doc(db, 'users', user.uid));
      
      if (!userDoc.exists()) {
        await setDoc(doc(db, 'users', user.uid), {
          email: user.email,
          role: 'artist',
          planId: 'free',
          createdAt: new Date(),
        });
        router.replace('/home-artist');
      } else {
        const userData = userDoc.data();
        router.replace(userData.role === 'artist' ? '/home-artist' : '/home-contractor');
      }
    } catch (error: any) {
      Alert.alert(i18n.t('common.error.login'), error.message);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Ionicons name="log-in-outline" size={32} color="#007AFF" />
        <Text style={styles.title}>{i18n.t('screens.login.title')}</Text>
      </View>
      <TextInput
        style={styles.input}
        placeholder={i18n.t('auth.email')}
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />
      <TextInput
        style={styles.input}
        placeholder={i18n.t('auth.password')}
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      <Button title={i18n.t('common.button.login')} onPress={handleLogin} />
      <Button
        title={i18n.t('screens.login.createAccount')}
        onPress={() => router.push('/register')}
        variant="secondary"
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: 30,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
    textAlign: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\notifications.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { Layout } from '../src/components/Layout';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, orderBy, getDocs, doc, updateDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { Notification, User } from '../src/types';

export default function NotificationsScreen() {
  const [notifications, setNotifications] = useState<(Notification & { sender: User })[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadNotifications();
  }, []);

  const loadNotifications = async () => {
    if (!auth.currentUser) return;

    try {
      const notificationsSnapshot = await getDocs(query(
        collection(db, 'notifications'),
        where('receiverId', '==', auth.currentUser.uid),
        where('seen', '==', false),
        orderBy('createdAt', 'desc')
      ));

      const notificationsWithUsers = await Promise.all(
        notificationsSnapshot.docs.map(async (doc) => {
          const notificationData = { id: doc.id, ...doc.data() } as Notification;
          const userDoc = await getDocs(query(
            collection(db, 'users'),
            where('id', '==', notificationData.senderId)
          ));

          if (!userDoc.empty) {
            return {
              ...notificationData,
              sender: userDoc.docs[0].data() as User,
            };
          }
          
          return null;
        })
      );

      setNotifications(notificationsWithUsers.filter(Boolean) as (Notification & { sender: User })[]);
    } catch (error) {
      console.error('Error loading notifications:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleNotificationPress = async (notification: Notification) => {
    try {
      // Mark as seen
      await updateDoc(doc(db, 'notifications', notification.id), {
        seen: true
      });

      // Navigate based on type
      switch (notification.type) {
        case 'chat':
          if (notification.chatId) {
            router.push(`/chat/${notification.chatId}`);
          }
          break;
        case 'event':
          if (notification.eventId) {
            router.push(`/events/${notification.eventId}`);
          }
          break;
        case 'candidacy':
          if (notification.candidacyId) {
            router.push(`/candidacies/${notification.candidacyId}`);
          }
          break;
      }

      loadNotifications();
    } catch (error) {
      console.error('Error handling notification:', error);
    }
  };

  const getNotificationIcon = (type: string) => {
    switch (type) {
      case 'chat':
        return 'chatbubble';
      case 'event':
        return 'calendar';
      case 'candidacy':
        return 'person';
      default:
        return 'notifications';
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="notifications" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('notifications.title')}</Text>
        </View>

        {notifications.map((notification) => (
          <TouchableOpacity
            key={notification.id}
            style={styles.notificationItem}
            onPress={() => handleNotificationPress(notification)}
          >
            <View style={styles.notificationIcon}>
              <Ionicons
                name={getNotificationIcon(notification.type)}
                size={24}
                color="#007AFF"
              />
            </View>

            <View style={styles.notificationContent}>
              <Text style={styles.notificationTitle}>
                {i18n.t(`notifications.type.${notification.type}`)}
              </Text>
              <Text style={styles.notificationSender}>
                {notification.sender.email}
              </Text>
              <Text style={styles.notificationTime}>
                {notification.createdAt.toLocaleString()}
              </Text>
            </View>
          </TouchableOpacity>
        ))}

        {!loading && notifications.length === 0 && (
          <Text style={styles.emptyText}>
            {i18n.t('notifications.empty')}
          </Text>
        )}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  notificationItem: {
    flexDirection: 'row',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  notificationIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#F0F0F0',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 15,
  },
  notificationContent: {
    flex: 1,
  },
  notificationTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 5,
  },
  notificationSender: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  notificationTime: {
    fontSize: 12,
    color: '#999',
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 16,
    color: '#666',
    marginTop: 20,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\plans.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert, TouchableOpacity, Platform } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { collection, doc, getDoc, updateDoc, addDoc } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { Plan, User } from '../src/types';

const MOCK_STRIPE_CHECKOUT = 'https://stripe.com/checkout';

const PLANS: Plan[] = [
  {
    id: 'free',
    name: 'Free',
    price: 0,
    features: [
      '100MB Storage',
      '10 Credits/month',
      '20 Messages/day',
      '3 Genres max',
      'Basic Events only'
    ],
    limits: {
      storage: 100,
      credits: 10,
      messages: 20,
      genres: 3,
      events: 1
    }
  },
  {
    id: 'paid',
    name: 'Premium',
    price: 29.99,
    features: [
      '2GB Storage',
      'Unlimited Credits',
      'Unlimited Messages',
      'Unlimited Genres',
      'All Event Types',
      'Priority Support'
    ],
    limits: {
      storage: 2048,
      credits: -1,
      messages: -1,
      genres: -1,
      events: -1
    }
  }
];

export default function PlansScreen() {
  const [currentPlan, setCurrentPlan] = useState<Plan | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadUserPlan();
  }, []);

  const loadUserPlan = async () => {
    if (!auth.currentUser) return;

    try {
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        setUser(userData);
        setCurrentPlan(PLANS.find(p => p.id === userData.planId) || null);
      }
    } catch (error) {
      console.error('Error loading user plan:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleUpgrade = async (plan: Plan) => {
    if (!auth.currentUser) return;

    try {
      // In a real app, this would redirect to Stripe Checkout
      if (Platform.OS === 'web') {
        // Simulate payment success
        await handlePaymentSuccess(plan);
      } else {
        Alert.alert(
          i18n.t('plans.alert.webOnly'),
          i18n.t('plans.alert.webOnlyMessage')
        );
      }
    } catch (error) {
      console.error('Error upgrading plan:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handlePaymentSuccess = async (plan: Plan) => {
    if (!auth.currentUser) return;

    try {
      // Create transaction record
      await addDoc(collection(db, 'transactions'), {
        userId: auth.currentUser.uid,
        planId: plan.id,
        status: 'completed',
        amount: plan.price,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // Update user's plan
      await updateDoc(doc(db, 'users', auth.currentUser.uid), {
        planId: plan.id,
        subscriptionStatus: 'active',
        subscriptionEndDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
      });

      Alert.alert(
        i18n.t('plans.success.title'),
        i18n.t('plans.success.message')
      );

      loadUserPlan();
    } catch (error) {
      console.error('Error processing payment:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleCancel = async () => {
    if (!auth.currentUser) return;

    try {
      await updateDoc(doc(db, 'users', auth.currentUser.uid), {
        planId: 'free',
        subscriptionStatus: 'canceled',
      });

      Alert.alert(
        i18n.t('plans.cancel.title'),
        i18n.t('plans.cancel.message')
      );

      loadUserPlan();
    } catch (error) {
      console.error('Error canceling subscription:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="card" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('plans.title')}</Text>
        </View>

        {currentPlan && (
          <View style={styles.currentPlan}>
            <Text style={styles.currentPlanText}>
              {i18n.t('plans.current', { plan: currentPlan.name })}
            </Text>
            {user?.planId === 'paid' && (
              <Button
                title={i18n.t('plans.cancel.button')}
                onPress={handleCancel}
                variant="secondary"
              />
            )}
          </View>
        )}

        <View style={styles.plansContainer}>
          {PLANS.map((plan) => (
            <View
              key={plan.id}
              style={[
                styles.planCard,
                plan.id === currentPlan?.id && styles.currentPlanCard
              ]}
            >
              <View style={styles.planHeader}>
                <Text style={styles.planName}>{plan.name}</Text>
                <Text style={styles.planPrice}>
                  ${plan.price.toFixed(2)}/month
                </Text>
              </View>

              <View style={styles.featuresContainer}>
                {plan.features.map((feature, index) => (
                  <View key={index} style={styles.featureItem}>
                    <Ionicons name="checkmark-circle" size={20} color="#4CAF50" />
                    <Text style={styles.featureText}>{feature}</Text>
                  </View>
                ))}
              </View>

              {plan.id !== currentPlan?.id && (
                <Button
                  title={i18n.t('plans.upgrade.button')}
                  onPress={() => handleUpgrade(plan)}
                />
              )}
            </View>
          ))}
        </View>
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  currentPlan: {
    backgroundColor: '#E3F2FD',
    padding: 15,
    borderRadius: 8,
    marginBottom: 20,
  },
  currentPlanText: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 10,
  },
  plansContainer: {
    gap: 20,
  },
  planCard: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  currentPlanCard: {
    borderColor: '#007AFF',
    borderWidth: 2,
  },
  planHeader: {
    alignItems: 'center',
    marginBottom: 20,
  },
  planName: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 5,
  },
  planPrice: {
    fontSize: 18,
    color: '#666',
  },
  featuresContainer: {
    marginBottom: 20,
  },
  featureItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  featureText: {
    marginLeft: 10,
    fontSize: 16,
    color: '#333',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\portfolio-artist.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert, ActivityIndicator } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { MediaList } from '../src/components/MediaList';
import { MediaUpload } from '../src/components/MediaUpload';
import { StorageUsage } from '../src/components/StorageUsage';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, orderBy, getDocs } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { Media, User } from '../src/types';

export default function PortfolioArtistScreen() {
  const [medias, setMedias] = useState<Media[]>([]);
  const [loading, setLoading] = useState(true);
  const [showUpload, setShowUpload] = useState(false);
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    loadPortfolio();
  }, []);

  const loadPortfolio = async () => {
    if (!auth.currentUser) return;

    try {
      const [userDoc, mediasSnapshot] = await Promise.all([
        getDocs(query(collection(db, 'users'), where('id', '==', auth.currentUser.uid))),
        getDocs(query(
          collection(db, 'media'),
          where('userId', '==', auth.currentUser.uid),
          orderBy('highlighted', 'desc'),
          orderBy('createdAt', 'desc')
        ))
      ]);

      if (!userDoc.empty) {
        setUser(userDoc.docs[0].data() as User);
      }

      const mediaList = mediasSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as Media[];

      setMedias(mediaList);
    } catch (error) {
      console.error('Error loading portfolio:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <Layout>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#007AFF" />
          <Text style={styles.loadingText}>{i18n.t('common.error.loading')}</Text>
        </View>
      </Layout>
    );
  }

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="images" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('portfolio.title')}</Text>
        </View>

        <StorageUsage user={user} />

        {showUpload ? (
          <MediaUpload
            onClose={() => setShowUpload(false)}
            onSuccess={() => {
              setShowUpload(false);
              loadPortfolio();
            }}
          />
        ) : (
          <Button
            title={i18n.t('common.button.upload')}
            onPress={() => setShowUpload(true)}
          />
        )}

        <MediaList
          medias={medias}
          onUpdate={loadPortfolio}
          isPaidPlan={user?.planId === 'paid'}
        />
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\portfolio-contractor.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert, ActivityIndicator } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { MediaList } from '../src/components/MediaList';
import { MediaUpload } from '../src/components/MediaUpload';
import { StorageUsage } from '../src/components/StorageUsage';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, orderBy, getDocs } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { Media, User } from '../src/types';

export default function PortfolioContractorScreen() {
  const [medias, setMedias] = useState<Media[]>([]);
  const [loading, setLoading] = useState(true);
  const [showUpload, setShowUpload] = useState(false);
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    loadPortfolio();
  }, []);

  const loadPortfolio = async () => {
    if (!auth.currentUser) return;

    try {
      const [userDoc, mediasSnapshot] = await Promise.all([
        getDocs(query(collection(db, 'users'), where('id', '==', auth.currentUser.uid))),
        getDocs(query(
          collection(db, 'media'),
          where('userId', '==', auth.currentUser.uid),
          orderBy('highlighted', 'desc'),
          orderBy('createdAt', 'desc')
        ))
      ]);

      if (!userDoc.empty) {
        setUser(userDoc.docs[0].data() as User);
      }

      const mediaList = mediasSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as Media[];

      setMedias(mediaList);
    } catch (error) {
      console.error('Error loading portfolio:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <Layout>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#007AFF" />
          <Text style={styles.loadingText}>{i18n.t('common.error.loading')}</Text>
        </View>
      </Layout>
    );
  }

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="images" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('portfolio.title')}</Text>
        </View>

        <StorageUsage user={user} />

        {showUpload ? (
          <MediaUpload
            onClose={() => setShowUpload(false)}
            onSuccess={() => {
              setShowUpload(false);
              loadPortfolio();
            }}
          />
        ) : (
          <Button
            title={i18n.t('common.button.upload')}
            onPress={() => setShowUpload(true)}
          />
        )}

        <MediaList
          medias={medias}
          onUpdate={loadPortfolio}
          isPaidPlan={user?.planId === 'paid'}
        />
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\register.tsx ---
import React, { useState } from 'react';
import { View, Text, TextInput, StyleSheet, Alert } from 'react-native';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { createUserWithEmailAndPassword } from 'firebase/auth';
import { doc, setDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { UserRole } from '../src/types';
import { Picker } from '@react-native-picker/picker';

export default function RegisterScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [role, setRole] = useState<UserRole>('artist');

  const handleRegister = async () => {
    try {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      const user = userCredential.user;

      // Create user document in Firestore
      await setDoc(doc(db, 'users', user.uid), {
        email: user.email,
        role,
        planId: 'free',
        createdAt: new Date(),
      });

      router.replace(role === 'artist' ? '/home-artist' : '/home-contractor');
    } catch (error: any) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Create Account</Text>
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />
      <TextInput
        style={styles.input}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      <View style={styles.roleContainer}>
        <Text style={styles.label}>I am a:</Text>
        <Picker
          selectedValue={role}
          onValueChange={(itemValue) => setRole(itemValue as UserRole)}
          style={styles.picker}
        >
          <Picker.Item label="Artist" value="artist" />
          <Picker.Item label="Contractor" value="contractor" />
        </Picker>
      </View>
      <Button title="Register" onPress={handleRegister} />
      <Button
        title="Already have an account? Login"
        onPress={() => router.push('/login')}
        variant="secondary"
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 30,
    textAlign: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
  },
  roleContainer: {
    marginBottom: 15,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
  },
  picker: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\reviews-pending.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert, TextInput } from 'react-native';
import { Layout } from '../src/components/Layout';
import { Button } from '../src/components/Button';
import { auth, db } from '../src/services/firebase';
import { collection, query, where, getDocs, addDoc, doc, getDoc, updateDoc, runTransaction } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../src/i18n';
import type { Event, Review, User } from '../src/types';

interface PendingReview {
  event: Event;
  otherUser: User;
}

export default function ReviewsPendingScreen() {
  const [pendingReviews, setPendingReviews] = useState<PendingReview[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedReview, setSelectedReview] = useState<PendingReview | null>(null);
  const [rating, setRating] = useState(5);
  const [comment, setComment] = useState('');

  useEffect(() => {
    loadPendingReviews();
  }, []);

  const loadPendingReviews = async () => {
    if (!auth.currentUser) return;

    try {
      // Get user's role
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      const userRole = userDoc.data()?.role;

      // Get completed events where user participated
      const eventsQuery = userRole === 'artist'
        ? query(
            collection(db, 'candidacies'),
            where('artistId', '==', auth.currentUser.uid),
            where('status', '==', 'APROVADA')
          )
        : query(
            collection(db, 'events'),
            where('creatorId', '==', auth.currentUser.uid),
            where('status', '==', 'CONCLUIDO')
          );

      const eventsSnapshot = await getDocs(eventsQuery);

      // Get events that haven't been reviewed
      const pending: PendingReview[] = [];
      
      for (const eventDoc of eventsSnapshot.docs) {
        const eventData = eventDoc.data();
        const eventId = eventRole === 'artist' ? eventData.eventId : eventDoc.id;

        // Check if already reviewed
        const reviewsQuery = query(
          collection(db, 'reviews'),
          where('eventId', '==', eventId),
          where('reviewerId', '==', auth.currentUser.uid)
        );
        const reviewsSnapshot = await getDocs(reviewsQuery);

        if (reviewsSnapshot.empty) {
          const event = (await getDoc(doc(db, 'events', eventId))).data() as Event;
          const otherUserId = userRole === 'artist' ? event.creatorId : eventData.artistId;
          const otherUser = (await getDoc(doc(db, 'users', otherUserId))).data() as User;

          pending.push({ event, otherUser });
        }
      }

      setPendingReviews(pending);
    } catch (error) {
      console.error('Error loading pending reviews:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleSubmitReview = async () => {
    if (!auth.currentUser || !selectedReview) return;

    try {
      await runTransaction(db, async (transaction) => {
        // Create review
        const reviewRef = doc(collection(db, 'reviews'));
        transaction.set(reviewRef, {
          reviewerId: auth.currentUser!.uid,
          reviewedId: selectedReview.otherUser.id,
          eventId: selectedReview.event.id,
          rating,
          comment,
          createdAt: new Date(),
        });

        // Update user's rating
        const userRef = doc(db, 'users', selectedReview.otherUser.id);
        const userDoc = await transaction.get(userRef);
        const userData = userDoc.data() as User;

        const newReviewCount = (userData.reviewCount || 0) + 1;
        const currentRating = userData.rating || 0;
        const newRating = ((currentRating * (newReviewCount - 1)) + rating) / newReviewCount;

        transaction.update(userRef, {
          rating: newRating,
          reviewCount: newReviewCount,
        });
      });

      Alert.alert(i18n.t('reviews.success.submitted'));
      setSelectedReview(null);
      setRating(5);
      setComment('');
      loadPendingReviews();
    } catch (error) {
      console.error('Error submitting review:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const renderStars = (count: number, onPress?: (value: number) => void) => {
    return (
      <View style={styles.starsContainer}>
        {[1, 2, 3, 4, 5].map((value) => (
          <Ionicons
            key={value}
            name={value <= count ? "star" : "star-outline"}
            size={24}
            color="#FFD700"
            onPress={() => onPress?.(value)}
          />
        ))}
      </View>
    );
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="star" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('reviews.pending.title')}</Text>
        </View>

        {selectedReview ? (
          <View style={styles.reviewForm}>
            <Text style={styles.subtitle}>
              {i18n.t('reviews.form.title', { name: selectedReview.otherUser.email })}
            </Text>

            <Text style={styles.label}>{i18n.t('reviews.form.rating')}</Text>
            {renderStars(rating, setRating)}

            <Text style={styles.label}>{i18n.t('reviews.form.comment')}</Text>
            <TextInput
              style={styles.input}
              value={comment}
              onChangeText={setComment}
              multiline
              numberOfLines={4}
              placeholder={i18n.t('reviews.form.commentPlaceholder')}
            />

            <View style={styles.formButtons}>
              <Button
                title={i18n.t('reviews.form.submit')}
                onPress={handleSubmitReview}
              />
              <Button
                title={i18n.t('common.button.cancel')}
                onPress={() => setSelectedReview(null)}
                variant="secondary"
              />
            </View>
          </View>
        ) : (
          pendingReviews.map((review) => (
            <View key={review.event.id} style={styles.reviewItem}>
              <View style={styles.eventInfo}>
                <Text style={styles.eventTitle}>{review.event.title}</Text>
                <Text style={styles.eventDate}>
                  {new Date(review.event.endDate).toLocaleDateString()}
                </Text>
              </View>

              <View style={styles.userInfo}>
                <Ionicons name="person" size={20} color="#666" />
                <Text style={styles.userName}>{review.otherUser.email}</Text>
              </View>

              <Button
                title={i18n.t('reviews.pending.writeReview')}
                onPress={() => setSelectedReview(review)}
              />
            </View>
          ))
        )}

        {!loading && pendingReviews.length === 0 && (
          <Text style={styles.emptyText}>
            {i18n.t('reviews.pending.empty')}
          </Text>
        )}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  subtitle: {
    fontSize: 18,
    textAlign: 'center',
    marginBottom: 20,
  },
  reviewItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  eventInfo: {
    marginBottom: 10,
  },
  eventTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  eventDate: {
    fontSize: 14,
    color: '#666',
  },
  userInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 15,
  },
  userName: {
    fontSize: 16,
    marginLeft: 10,
  },
  reviewForm: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  starsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: 15,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
    textAlignVertical: 'top',
  },
  formButtons: {
    gap: 10,
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 16,
    color: '#666',
    marginTop: 20,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\_layout.tsx ---
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider, initialWindowMetrics } from 'react-native-safe-area-context';
import { Platform } from 'react-native';
import { useEffect, useRef } from 'react';
import * as Notifications from 'expo-notifications';
import { router } from 'expo-router';
import { ErrorBoundary } from '../src/components/ErrorBoundary';
import { registerForPushNotificationsAsync, updatePushToken } from '../src/services/notifications';
import '../src/services/firebase';

export default function RootLayout() {
  const notificationListener = useRef<any>();
  const responseListener = useRef<any>();

  useEffect(() => {
    registerPushNotifications();
    setupNotificationListeners();

    return () => {
      if (notificationListener.current) {
        Notifications.removeNotificationSubscription(notificationListener.current);
      }
      if (responseListener.current) {
        Notifications.removeNotificationSubscription(responseListener.current);
      }
    };
  }, []);

  const registerPushNotifications = async () => {
    if (Platform.OS !== 'web') {
      const token = await registerForPushNotificationsAsync();
      if (token) {
        await updatePushToken(token);
      }
    }
  };

  const setupNotificationListeners = () => {
    notificationListener.current = Notifications.addNotificationReceivedListener(notification => {
      // Handle received notification
      console.log('Notification received:', notification);
    });

    responseListener.current = Notifications.addNotificationResponseReceivedListener(response => {
      const data = response.notification.request.content.data;

      // Handle notification tap
      if (data.type === 'chat' && data.chatId) {
        router.push(`/chat/${data.chatId}`);
      } else if (data.type === 'event' && data.eventId) {
        router.push(`/events/${data.eventId}`);
      } else if (data.type === 'candidacy' && data.candidacyId) {
        router.push(`/candidacies/${data.candidacyId}`);
      }
    });
  };

  return (
    <SafeAreaProvider initialMetrics={initialWindowMetrics}>
      <ErrorBoundary>
        <Stack
          screenOptions={{
            headerShown: false,
            contentStyle: Platform.select({
              web: { backgroundColor: 'white' },
              default: undefined,
            }),
          }}
        >
          <Stack.Screen name="index" />
          <Stack.Screen name="login" />
          <Stack.Screen name="register" />
          <Stack.Screen name="home-artist" />
          <Stack.Screen name="home-contractor" />
          <Stack.Screen name="edit-artist-profile" />
          <Stack.Screen name="edit-contractor-profile" />
          <Stack.Screen name="portfolio-artist" />
          <Stack.Screen name="portfolio-contractor" />
          <Stack.Screen name="notifications" />
          <Stack.Screen name="chats" />
          <Stack.Screen name="chat/[id]" />
        </Stack>
        <StatusBar style="auto" />
      </ErrorBoundary>
    </SafeAreaProvider>
  );
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\dashboard.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Platform } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { auth, db } from '../../src/services/firebase';
import { collection, query, where, getDocs, orderBy } from 'firebase/firestore';
import { Ionicons } from '@expo/vector-icons';
import { format, subDays, isWithinInterval, startOfDay, endOfDay } from 'date-fns';
import { router } from 'expo-router';
import i18n from '../../src/i18n';
import type { User, Event } from '../../src/types';

// Import Chart.js components only on web platform
let Line: any;
let Pie: any;
if (Platform.OS === 'web') {
  const { Line: WebLine, Pie: WebPie } = require('react-chartjs-2');
  const { Chart, registerables } = require('chart.js');
  Chart.register(...registerables);
  Line = WebLine;
  Pie = WebPie;
}

type Period = '7d' | '30d' | 'custom';
type ChartData = { dates: string[]; values: number[] };
type PieChartData = { labels: string[]; values: number[] };

export default function AdminDashboardScreen() {
  const [loading, setLoading] = useState(true);
  const [period, setPeriod] = useState<Period>('7d');

  const [usersData, setUsersData] = useState<{
    total: number;
    artists: number;
    contractors: number;
    admins: number;
    free: number;
    paid: number;
    chart: ChartData;
    roleChart: PieChartData;
    planChart: PieChartData;
  }>({
    total: 0,
    artists: 0,
    contractors: 0,
    admins: 0,
    free: 0,
    paid: 0,
    chart: { dates: [], values: [] },
    roleChart: { labels: [], values: [] },
    planChart: { labels: [], values: [] },
  });

  const [eventsData, setEventsData] = useState<{
    total: number;
    open: number;
    closed: number;
    canceled: number;
    completed: number;
    shows: number;
    festivals: number;
    chart: ChartData;
    statusChart: PieChartData;
    typeChart: PieChartData;
  }>({
    total: 0,
    open: 0,
    closed: 0,
    canceled: 0,
    completed: 0,
    shows: 0,
    festivals: 0,
    chart: { dates: [], values: [] },
    statusChart: { labels: [], values: [] },
    typeChart: { labels: [], values: [] },
  });

  const [ratingsData, setRatingsData] = useState<{
    globalAverage: number;
    totalReviews: number;
    topArtists: { email: string; rating: number }[];
    topContractors: { email: string; rating: number }[];
    chart: ChartData;
  }>({
    globalAverage: 0,
    totalReviews: 0,
    topArtists: [],
    topContractors: [],
    chart: { dates: [], values: [] },
  });

  useEffect(() => {
    loadDashboard();
  }, [period]);

  const loadDashboard = async () => {
    if (!auth.currentUser) return;

    try {
      const periodDays = period === '7d' ? 7 : 30;
      const startDate = subDays(new Date(), periodDays);

      // Generate dates array for charts
      const dates = Array.from({ length: periodDays }, (_, i) => {
        const date = subDays(new Date(), i);
        return format(date, 'yyyy-MM-dd');
      }).reverse();

      // Load users data
      const usersSnapshot = await getDocs(collection(db, 'users'));
      const users = usersSnapshot.docs.map(doc => ({
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
      })) as User[];

      const recentUsers = users.filter(u =>
        isWithinInterval(u.createdAt, {
          start: startOfDay(startDate),
          end: endOfDay(new Date()),
        })
      );

      // Calculate users per day
      const usersPerDay = dates.map(date => {
        return recentUsers.filter(u =>
          format(u.createdAt, 'yyyy-MM-dd') === date
        ).length;
      });

      setUsersData({
        total: users.length,
        artists: users.filter(u => u.role === 'artist').length,
        contractors: users.filter(u => u.role === 'contractor').length,
        admins: users.filter(u => u.isAdmin).length,
        free: users.filter(u => u.planId === 'free').length,
        paid: users.filter(u => u.planId === 'paid').length,
        chart: {
          dates,
          values: usersPerDay,
        },
        roleChart: {
          labels: ['Artists', 'Contractors', 'Admins'],
          values: [
            users.filter(u => u.role === 'artist').length,
            users.filter(u => u.role === 'contractor').length,
            users.filter(u => u.isAdmin).length,
          ],
        },
        planChart: {
          labels: ['Free', 'Paid'],
          values: [
            users.filter(u => u.planId === 'free').length,
            users.filter(u => u.planId === 'paid').length,
          ],
        },
      });

      // Load events data
      const eventsSnapshot = await getDocs(collection(db, 'events'));
      const events = eventsSnapshot.docs.map(doc => ({
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
      })) as Event[];

      const recentEvents = events.filter(e =>
        isWithinInterval(e.createdAt, {
          start: startOfDay(startDate),
          end: endOfDay(new Date()),
        })
      );

      // Calculate events per day
      const eventsPerDay = dates.map(date => {
        return recentEvents.filter(e =>
          format(e.createdAt, 'yyyy-MM-dd') === date
        ).length;
      });

      setEventsData({
        total: events.length,
        open: events.filter(e => e.status === 'ABERTO').length,
        closed: events.filter(e => e.status === 'ENCERRADO').length,
        canceled: events.filter(e => e.status === 'CANCELADO').length,
        completed: events.filter(e => e.status === 'CONCLUIDO').length,
        shows: events.filter(e => e.eventType === 'SHOW').length,
        festivals: events.filter(e => e.eventType === 'FESTIVAL').length,
        chart: {
          dates,
          values: eventsPerDay,
        },
        statusChart: {
          labels: ['Open', 'Closed', 'Canceled', 'Completed'],
          values: [
            events.filter(e => e.status === 'ABERTO').length,
            events.filter(e => e.status === 'ENCERRADO').length,
            events.filter(e => e.status === 'CANCELADO').length,
            events.filter(e => e.status === 'CONCLUIDO').length,
          ],
        },
        typeChart: {
          labels: ['Shows', 'Festivals'],
          values: [
            events.filter(e => e.eventType === 'SHOW').length,
            events.filter(e => e.eventType === 'FESTIVAL').length,
          ],
        },
      });

      // Load ratings data
      const reviewsSnapshot = await getDocs(collection(db, 'reviews'));
      const reviews = reviewsSnapshot.docs.map(doc => ({
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
      }));

      const recentReviews = reviews.filter(r =>
        isWithinInterval(r.createdAt, {
          start: startOfDay(startDate),
          end: endOfDay(new Date()),
        })
      );

      // Calculate reviews per day
      const reviewsPerDay = dates.map(date => {
        return recentReviews.filter(r =>
          format(r.createdAt, 'yyyy-MM-dd') === date
        ).length;
      });

      // Get top rated users
      const artistsWithRatings = users
        .filter(u => u.role === 'artist' && u.rating)
        .sort((a, b) => (b.rating || 0) - (a.rating || 0))
        .slice(0, 5)
        .map(u => ({ email: u.email, rating: u.rating || 0 }));

      const contractorsWithRatings = users
        .filter(u => u.role === 'contractor' && u.rating)
        .sort((a, b) => (b.rating || 0) - (a.rating || 0))
        .slice(0, 5)
        .map(u => ({ email: u.email, rating: u.rating || 0 }));

      setRatingsData({
        globalAverage: users.reduce((sum, u) => sum + (u.rating || 0), 0) / users.filter(u => u.rating).length,
        totalReviews: reviews.length,
        topArtists: artistsWithRatings,
        topContractors: contractorsWithRatings,
        chart: {
          dates,
          values: reviewsPerDay,
        },
      });
    } catch (error) {
      console.error('Error loading dashboard:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderLineChart = (data: ChartData, label: string, color: string) => {
    if (Platform.OS !== 'web') {
      return (
        <View style={styles.simpleChart}>
          {data.values.map((value, index) => (
            <View
              key={index}
              style={[
                styles.chartBar,
                {
                  height: `${(value / Math.max(...data.values)) * 100}%`,
                  backgroundColor: color,
                },
              ]}
            />
          ))}
        </View>
      );
    }

    return (
      <Line
        data={{
          labels: data.dates.map(date => format(new Date(date), 'dd/MM')),
          datasets: [
            {
              label,
              data: data.values,
              fill: false,
              borderColor: color,
              tension: 0.1,
            },
          ],
        }}
        options={{
          responsive: true,
          plugins: {
            legend: {
              position: 'top' as const,
            },
          },
          scales: {
            y: {
              beginAtZero: true,
            },
          },
        }}
      />
    );
  };

  const renderPieChart = (data: PieChartData, colors: string[]) => {
    if (Platform.OS !== 'web') {
      return (
        <View style={styles.simplePieChart}>
          {data.values.map((value, index) => (
            <View
              key={index}
              style={[
                styles.pieSlice,
                {
                  flex: value,
                  backgroundColor: colors[index],
                },
              ]}
            />
          ))}
        </View>
      );
    }

    return (
      <Pie
        data={{
          labels: data.labels,
          datasets: [
            {
              data: data.values,
              backgroundColor: colors,
            },
          ],
        }}
        options={{
          responsive: true,
          plugins: {
            legend: {
              position: 'right' as const,
            },
          },
        }}
      />
    );
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <Ionicons name="arrow-back" size={24} color="#007AFF" />
          </TouchableOpacity>
          <View style={styles.headerContent}>
            <Ionicons name="stats-chart" size={32} color="#007AFF" />
            <Text style={styles.title}>{i18n.t('admin.dashboard.title')}</Text>
          </View>
        </View>

        <View style={styles.periodSelector}>
          <Button
            title="7 dias"
            onPress={() => setPeriod('7d')}
            variant={period === '7d' ? 'primary' : 'secondary'}
          />
          <Button
            title="30 dias"
            onPress={() => setPeriod('30d')}
            variant={period === '30d' ? 'primary' : 'secondary'}
          />
        </View>

        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>{i18n.t('admin.dashboard.users.title')}</Text>
            <TouchableOpacity
              style={styles.sectionLink}
              onPress={() => router.push('/admin/users')}
            >
              <Text style={styles.linkText}>{i18n.t('admin.dashboard.viewAll')}</Text>
              <Ionicons name="arrow-forward" size={16} color="#007AFF" />
            </TouchableOpacity>
          </View>

          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{usersData.total}</Text>
              <Text style={styles.statLabel}>{i18n.t('admin.dashboard.users.total')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#4CAF50' }]}>{usersData.artists}</Text>
              <Text style={styles.statLabel}>{i18n.t('admin.dashboard.users.artists')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#2196F3' }]}>{usersData.contractors}</Text>
              <Text style={styles.statLabel}>{i18n.t('admin.dashboard.users.contractors')}</Text>
            </View>
          </View>

          <View style={styles.chart}>
            {renderLineChart(
              usersData.chart,
              i18n.t('admin.dashboard.users.newUsers'),
              '#007AFF'
            )}
          </View>

          <View style={styles.chartsRow}>
            <View style={[styles.chart, styles.halfChart]}>
              {renderPieChart(
                usersData.roleChart,
                ['#4CAF50', '#2196F3', '#FF9800']
              )}
            </View>
            <View style={[styles.chart, styles.halfChart]}>
              {renderPieChart(
                usersData.planChart,
                ['#F44336', '#4CAF50']
              )}
            </View>
          </View>
        </View>

        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>{i18n.t('admin.dashboard.events.title')}</Text>
            <TouchableOpacity
              style={styles.sectionLink}
              onPress={() => router.push('/admin/events')}
            >
              <Text style={styles.linkText}>{i18n.t('admin.dashboard.viewAll')}</Text>
              <Ionicons name="arrow-forward" size={16} color="#007AFF" />
            </TouchableOpacity>
          </View>

          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{eventsData.total}</Text>
              <Text style={styles.statLabel}>{i18n.t('admin.dashboard.events.total')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#4CAF50' }]}>{eventsData.shows}</Text>
              <Text style={styles.statLabel}>{i18n.t('admin.dashboard.events.shows')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={[styles.statValue, { color: '#FF9800' }]}>{eventsData.festivals}</Text>
              <Text style={styles.statLabel}>{i18n.t('admin.dashboard.events.festivals')}</Text>
            </View>
          </View>

          <View style={styles.chart}>
            {renderLineChart(
              eventsData.chart,
              i18n.t('admin.dashboard.events.newEvents'),
              '#4CAF50'
            )}
          </View>

          <View style={styles.chartsRow}>
            <View style={[styles.chart, styles.halfChart]}>
              {renderPieChart(
                eventsData.statusChart,
                ['#4CAF50', '#FFC107', '#F44336', '#2196F3']
              )}
            </View>
            <View style={[styles.chart, styles.halfChart]}>
              {renderPieChart(
                eventsData.typeChart,
                ['#2196F3', '#FF9800']
              )}
            </View>
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{i18n.t('admin.dashboard.ratings.title')}</Text>

          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{ratingsData.globalAverage.toFixed(1)}</Text>
              <Text style={styles.statLabel}>{i18n.t('admin.dashboard.ratings.average')}</Text>
            </View>
            <View style={styles.statCard}>
              <Text style={styles.statValue}>{ratingsData.totalReviews}</Text>
              <Text style={styles.statLabel}>{i18n.t('admin.dashboard.ratings.total')}</Text>
            </View>
          </View>

          <View style={styles.chart}>
            {renderLineChart(
              ratingsData.chart,
              i18n.t('admin.dashboard.ratings.newReviews'),
              '#FF9800'
            )}
          </View>

          <View style={styles.topUsers}>
            <View style={styles.topSection}>
              <Text style={styles.topTitle}>{i18n.t('admin.dashboard.ratings.topArtists')}</Text>
              {ratingsData.topArtists.map((artist, index) => (
                <View key={index} style={styles.topItem}>
                  <Text style={styles.topEmail}>{artist.email}</Text>
                  <Text style={styles.topRating}>{artist.rating.toFixed(1)}</Text>
                </View>
              ))}
            </View>

            <View style={styles.topSection}>
              <Text style={styles.topTitle}>{i18n.t('admin.dashboard.ratings.topContractors')}</Text>
              {ratingsData.topContractors.map((contractor, index) => (
                <View key={index} style={styles.topItem}>
                  <Text style={styles.topEmail}>{contractor.email}</Text>
                  <Text style={styles.topRating}>{contractor.rating.toFixed(1)}</Text>
                </View>
              ))}
            </View>
          </View>
        </View>
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 30,
  },
  backButton: {
    padding: 10,
  },
  headerContent: {
    flex: 1,
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  periodSelector: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 10,
    marginBottom: 20,
  },
  section: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  sectionLink: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 5,
  },
  linkText: {
    color: '#007AFF',
    fontSize: 14,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  statCard: {
    width: '31%',
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    padding: 15,
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#007AFF',
    marginBottom: 5,
  },
  statLabel: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
  },
  chart: {
    height: 200,
    marginTop: 20,
  },
  chartsRow: {
    flexDirection: 'row',
    gap: 20,
    marginTop: 20,
  },
  halfChart: {
    flex: 1,
    height: 200,
  },
  simpleChart: {
    flexDirection: 'row',
    height: '100%',
    alignItems: 'flex-end',
    gap: 2,
  },
  chartBar: {
    flex: 1,
    backgroundColor: '#007AFF',
    minHeight: 1,
  },
  simplePieChart: {
    flexDirection: 'row',
    height: '100%',
  },
  pieSlice: {
    height: '100%',
  },
  topUsers: {
    flexDirection: 'row',
    gap: 20,
    marginTop: 20,
  },
  topSection: {
    flex: 1,
  },
  topTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  topItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  topEmail: {
    fontSize: 14,
    color: '#333',
  },
  topRating: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#007AFF',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\event-types.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, Alert, TouchableOpacity } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { auth, db } from '../../src/services/firebase';
import { collection, query, orderBy, getDocs, doc, setDoc, updateDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';

interface EventType {
  id: string;
  name: string;
  description: string;
  planAllowed: string[];
  active: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export default function AdminEventTypesScreen() {
  const [eventTypes, setEventTypes] = useState<EventType[]>([]);
  const [loading, setLoading] = useState(true);
  const [newType, setNewType] = useState({
    name: '',
    description: '',
    planAllowed: ['free', 'paid'],
  });
  const [editingType, setEditingType] = useState<EventType | null>(null);

  useEffect(() => {
    loadEventTypes();
  }, []);

  const loadEventTypes = async () => {
    try {
      const typesSnapshot = await getDocs(query(
        collection(db, 'eventTypes'),
        orderBy('name', 'asc')
      ));

      const typesList = typesSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as EventType[];

      setEventTypes(typesList);
    } catch (error) {
      console.error('Error loading event types:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async () => {
    if (!newType.name.trim() || !newType.description.trim()) return;

    try {
      const typeDoc = doc(collection(db, 'eventTypes'));
      await setDoc(typeDoc, {
        name: newType.name.trim(),
        description: newType.description.trim(),
        planAllowed: newType.planAllowed,
        active: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      setNewType({
        name: '',
        description: '',
        planAllowed: ['free', 'paid'],
      });
      Alert.alert(i18n.t('admin.eventTypes.success.created'));
      loadEventTypes();
    } catch (error) {
      console.error('Error creating event type:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleUpdate = async (type: EventType) => {
    try {
      await updateDoc(doc(db, 'eventTypes', type.id), {
        name: type.name,
        description: type.description,
        planAllowed: type.planAllowed,
        updatedAt: new Date(),
      });

      setEditingType(null);
      Alert.alert(i18n.t('admin.eventTypes.success.updated'));
      loadEventTypes();
    } catch (error) {
      console.error('Error updating event type:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleToggleActive = async (type: EventType) => {
    try {
      await updateDoc(doc(db, 'eventTypes', type.id), {
        active: !type.active,
        updatedAt: new Date(),
      });

      Alert.alert(
        type.active
          ? i18n.t('admin.eventTypes.success.deactivated')
          : i18n.t('admin.eventTypes.success.activated')
      );
      loadEventTypes();
    } catch (error) {
      console.error('Error toggling event type:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleTogglePlan = (type: EventType, plan: string) => {
    const planAllowed = type.planAllowed.includes(plan)
      ? type.planAllowed.filter(p => p !== plan)
      : [...type.planAllowed, plan];

    setEditingType({
      ...type,
      planAllowed,
    });
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <Ionicons name="arrow-back" size={24} color="#007AFF" />
          </TouchableOpacity>
          <View style={styles.headerContent}>
            <Ionicons name="calendar" size={32} color="#007AFF" />
            <Text style={styles.title}>{i18n.t('admin.eventTypes.title')}</Text>
          </View>
        </View>

        <View style={styles.createForm}>
          <Text style={styles.label}>{i18n.t('admin.eventTypes.form.name')}</Text>
          <TextInput
            style={styles.input}
            value={newType.name}
            onChangeText={(text) => setNewType({ ...newType, name: text })}
            placeholder={i18n.t('admin.eventTypes.form.namePlaceholder')}
          />

          <Text style={styles.label}>{i18n.t('admin.eventTypes.form.description')}</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={newType.description}
            onChangeText={(text) => setNewType({ ...newType, description: text })}
            placeholder={i18n.t('admin.eventTypes.form.descriptionPlaceholder')}
            multiline
            numberOfLines={4}
          />

          <Text style={styles.label}>{i18n.t('admin.eventTypes.form.plans')}</Text>
          <View style={styles.plansContainer}>
            <Button
              title="Free"
              onPress={() => setNewType({
                ...newType,
                planAllowed: newType.planAllowed.includes('free')
                  ? newType.planAllowed.filter(p => p !== 'free')
                  : [...newType.planAllowed, 'free']
              })}
              variant={newType.planAllowed.includes('free') ? 'primary' : 'secondary'}
            />
            <Button
              title="Paid"
              onPress={() => setNewType({
                ...newType,
                planAllowed: newType.planAllowed.includes('paid')
                  ? newType.planAllowed.filter(p => p !== 'paid')
                  : [...newType.planAllowed, 'paid']
              })}
              variant={newType.planAllowed.includes('paid') ? 'primary' : 'secondary'}
            />
          </View>

          <Button
            title={i18n.t('common.button.create')}
            onPress={handleCreate}
            disabled={!newType.name.trim() || !newType.description.trim()}
          />
        </View>

        {eventTypes.map((type) => (
          <View key={type.id} style={styles.typeItem}>
            {editingType?.id === type.id ? (
              <View style={styles.editForm}>
                <TextInput
                  style={styles.input}
                  value={editingType.name}
                  onChangeText={(text) => setEditingType({ ...editingType, name: text })}
                />

                <TextInput
                  style={[styles.input, styles.textArea]}
                  value={editingType.description}
                  onChangeText={(text) => setEditingType({ ...editingType, description: text })}
                  multiline
                  numberOfLines={4}
                />

                <View style={styles.plansContainer}>
                  <Button
                    title="Free"
                    onPress={() => handleTogglePlan(editingType, 'free')}
                    variant={editingType.planAllowed.includes('free') ? 'primary' : 'secondary'}
                  />
                  <Button
                    title="Paid"
                    onPress={() => handleTogglePlan(editingType, 'paid')}
                    variant={editingType.planAllowed.includes('paid') ? 'primary' : 'secondary'}
                  />
                </View>

                <View style={styles.editButtons}>
                  <Button
                    title={i18n.t('common.button.save')}
                    onPress={() => handleUpdate(editingType)}
                  />
                  <Button
                    title={i18n.t('common.button.cancel')}
                    onPress={() => setEditingType(null)}
                    variant="secondary"
                  />
                </View>
              </View>
            ) : (
              <>
                <View style={styles.typeHeader}>
                  <Text style={styles.typeName}>{type.name}</Text>
                  <View style={styles.statusBadge}>
                    <Text style={styles.statusText}>
                      {type.active
                        ? i18n.t('admin.eventTypes.status.active')
                        : i18n.t('admin.eventTypes.status.inactive')}
                    </Text>
                  </View>
                </View>

                <Text style={styles.typeDescription}>{type.description}</Text>

                <View style={styles.plansInfo}>
                  <Text style={styles.plansLabel}>{i18n.t('admin.eventTypes.allowedPlans')}:</Text>
                  <View style={styles.planBadges}>
                    {type.planAllowed.map((plan) => (
                      <View key={plan} style={styles.planBadge}>
                        <Text style={styles.planText}>{plan}</Text>
                      </View>
                    ))}
                  </View>
                </View>

                <View style={styles.typeActions}>
                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => setEditingType(type)}
                  >
                    <Ionicons name="create-outline" size={24} color="#007AFF" />
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => handleToggleActive(type)}
                  >
                    <Ionicons
                      name={type.active ? "eye-off-outline" : "eye-outline"}
                      size={24}
                      color={type.active ? "#F44336" : "#4CAF50"}
                    />
                  </TouchableOpacity>
                </View>
              </>
            )}
          </View>
        ))}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 30,
  },
  backButton: {
    padding: 10,
  },
  headerContent: {
    flex: 1,
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  createForm: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  plansContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 15,
  },
  typeItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  typeHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  typeName: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
    backgroundColor: '#f0f0f0',
  },
  statusText: {
    fontSize: 12,
    color: '#666',
  },
  typeDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 10,
  },
  plansInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  plansLabel: {
    fontSize: 14,
    color: '#666',
    marginRight: 10,
  },
  planBadges: {
    flexDirection: 'row',
    gap: 5,
  },
  planBadge: {
    backgroundColor: '#E3F2FD',
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
  },
  planText: {
    fontSize: 12,
    color: '#007AFF',
  },
  typeActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
  actionButton: {
    padding: 5,
  },
  editForm: {
    gap: 10,
  },
  editButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\feedback-criteria.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, Alert, TouchableOpacity } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { auth, db } from '../../src/services/firebase';
import { collection, query, orderBy, getDocs, doc, setDoc, updateDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';

interface FeedbackCriterion {
  id: string;
  name: string;
  weight: number;
  appliesTo: 'artist' | 'contractor' | 'both';
  active: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export default function AdminFeedbackCriteriaScreen() {
  const [criteria, setCriteria] = useState<FeedbackCriterion[]>([]);
  const [loading, setLoading] = useState(true);
  const [newCriterion, setNewCriterion] = useState({
    name: '',
    weight: 1,
    appliesTo: 'both' as const,
  });
  const [editingCriterion, setEditingCriterion] = useState<FeedbackCriterion | null>(null);

  useEffect(() => {
    loadCriteria();
  }, []);

  const loadCriteria = async () => {
    try {
      const criteriaSnapshot = await getDocs(query(
        collection(db, 'feedbackCriteria'),
        orderBy('name', 'asc')
      ));

      const criteriaList = criteriaSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as FeedbackCriterion[];

      setCriteria(criteriaList);
    } catch (error) {
      console.error('Error loading feedback criteria:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async () => {
    if (!newCriterion.name.trim()) return;

    try {
      const criterionDoc = doc(collection(db, 'feedbackCriteria'));
      await setDoc(criterionDoc, {
        name: newCriterion.name.trim(),
        weight: Number(newCriterion.weight) || 1,
        appliesTo: newCriterion.appliesTo,
        active: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      setNewCriterion({
        name: '',
        weight: 1,
        appliesTo: 'both',
      });
      Alert.alert(i18n.t('admin.feedbackCriteria.success.created'));
      loadCriteria();
    } catch (error) {
      console.error('Error creating criterion:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleUpdate = async (criterion: FeedbackCriterion) => {
    try {
      await updateDoc(doc(db, 'feedbackCriteria', criterion.id), {
        name: criterion.name,
        weight: Number(criterion.weight) || 1,
        appliesTo: criterion.appliesTo,
        updatedAt: new Date(),
      });

      setEditingCriterion(null);
      Alert.alert(i18n.t('admin.feedbackCriteria.success.updated'));
      loadCriteria();
    } catch (error) {
      console.error('Error updating criterion:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleToggleActive = async (criterion: FeedbackCriterion) => {
    try {
      await updateDoc(doc(db, 'feedbackCriteria', criterion.id), {
        active: !criterion.active,
        updatedAt: new Date(),
      });

      Alert.alert(
        criterion.active
          ? i18n.t('admin.feedbackCriteria.success.deactivated')
          : i18n.t('admin.feedbackCriteria.success.activated')
      );
      loadCriteria();
    } catch (error) {
      console.error('Error toggling criterion:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const getAppliesTo = (type: string) => {
    switch (type) {
      case 'artist':
        return i18n.t('admin.feedbackCriteria.appliesTo.artist');
      case 'contractor':
        return i18n.t('admin.feedbackCriteria.appliesTo.contractor');
      case 'both':
        return i18n.t('admin.feedbackCriteria.appliesTo.both');
      default:
        return type;
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <Ionicons name="arrow-back" size={24} color="#007AFF" />
          </TouchableOpacity>
          <View style={styles.headerContent}>
            <Ionicons name="star" size={32} color="#007AFF" />
            <Text style={styles.title}>{i18n.t('admin.feedbackCriteria.title')}</Text>
          </View>
        </View>

        <View style={styles.createForm}>
          <Text style={styles.label}>{i18n.t('admin.feedbackCriteria.form.name')}</Text>
          <TextInput
            style={styles.input}
            value={newCriterion.name}
            onChangeText={(text) => setNewCriterion({ ...newCriterion, name: text })}
            placeholder={i18n.t('admin.feedbackCriteria.form.namePlaceholder')}
          />

          <Text style={styles.label}>{i18n.t('admin.feedbackCriteria.form.weight')}</Text>
          <TextInput
            style={styles.input}
            value={String(newCriterion.weight)}
            onChangeText={(text) => setNewCriterion({ ...newCriterion, weight: Number(text) || 1 })}
            keyboardType="numeric"
            placeholder="1-5"
          />

          <Text style={styles.label}>{i18n.t('admin.feedbackCriteria.form.appliesTo')}</Text>
          <View style={styles.appliesToContainer}>
            <Button
              title={i18n.t('admin.feedbackCriteria.appliesTo.artist')}
              onPress={() => setNewCriterion({ ...newCriterion, appliesTo: 'artist' })}
              variant={newCriterion.appliesTo === 'artist' ? 'primary' : 'secondary'}
            />
            <Button
              title={i18n.t('admin.feedbackCriteria.appliesTo.contractor')}
              onPress={() => setNewCriterion({ ...newCriterion, appliesTo: 'contractor' })}
              variant={newCriterion.appliesTo === 'contractor' ? 'primary' : 'secondary'}
            />
            <Button
              title={i18n.t('admin.feedbackCriteria.appliesTo.both')}
              onPress={() => setNewCriterion({ ...newCriterion, appliesTo: 'both' })}
              variant={newCriterion.appliesTo === 'both' ? 'primary' : 'secondary'}
            />
          </View>

          <Button
            title={i18n.t('common.button.create')}
            onPress={handleCreate}
            disabled={!newCriterion.name.trim()}
          />
        </View>

        {criteria.map((criterion) => (
          <View key={criterion.id} style={styles.criterionItem}>
            {editingCriterion?.id === criterion.id ? (
              <View style={styles.editForm}>
                <TextInput
                  style={styles.input}
                  value={editingCriterion.name}
                  onChangeText={(text) => setEditingCriterion({ ...editingCriterion, name: text })}
                />

                <TextInput
                  style={styles.input}
                  value={String(editingCriterion.weight)}
                  onChangeText={(text) => setEditingCriterion({ ...editingCriterion, weight: Number(text) || 1 })}
                  keyboardType="numeric"
                />

                <View style={styles.appliesToContainer}>
                  <Button
                    title={i18n.t('admin.feedbackCriteria.appliesTo.artist')}
                    onPress={() => setEditingCriterion({ ...editingCriterion, appliesTo: 'artist' })}
                    variant={editingCriterion.appliesTo === 'artist' ? 'primary' : 'secondary'}
                  />
                  <Button
                    title={i18n.t('admin.feedbackCriteria.appliesTo.contractor')}
                    onPress={() => setEditingCriterion({ ...editingCriterion, appliesTo: 'contractor' })}
                    variant={editingCriterion.appliesTo === 'contractor' ? 'primary' : 'secondary'}
                  />
                  <Button
                    title={i18n.t('admin.feedbackCriteria.appliesTo.both')}
                    onPress={() => setEditingCriterion({ ...editingCriterion, appliesTo: 'both' })}
                    variant={editingCriterion.appliesTo === 'both' ? 'primary' : 'secondary'}
                  />
                </View>

                <View style={styles.editButtons}>
                  <Button
                    title={i18n.t('common.button.save')}
                    onPress={() => handleUpdate(editingCriterion)}
                  />
                  <Button
                    title={i18n.t('common.button.cancel')}
                    onPress={() => setEditingCriterion(null)}
                    variant="secondary"
                  />
                </View>
              </View>
            ) : (
              <>
                <View style={styles.criterionHeader}>
                  <Text style={styles.criterionName}>{criterion.name}</Text>
                  <View style={styles.statusBadge}>
                    <Text style={styles.statusText}>
                      {criterion.active
                        ? i18n.t('admin.feedbackCriteria.status.active')
                        : i18n.t('admin.feedbackCriteria.status.inactive')}
                    </Text>
                  </View>
                </View>

                <View style={styles.criterionDetails}>
                  <Text style={styles.detailText}>
                    {i18n.t('admin.feedbackCriteria.weight')}: {criterion.weight}
                  </Text>
                  <Text style={styles.detailText}>
                    {i18n.t('admin.feedbackCriteria.appliesTo.label')}: {getAppliesTo(criterion.appliesTo)}
                  </Text>
                </View>

                <View style={styles.criterionActions}>
                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => setEditingCriterion(criterion)}
                  >
                    <Ionicons name="create-outline" size={24} color="#007AFF" />
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => handleToggleActive(criterion)}
                  >
                    <Ionicons
                      name={criterion.active ? "eye-off-outline" : "eye-outline"}
                      size={24}
                      color={criterion.active ? "#F44336" : "#4CAF50"}
                    />
                  </TouchableOpacity>
                </View>
              </>
            )}
          </View>
        ))}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 30,
  },
  backButton: {
    padding: 10,
  },
  headerContent: {
    flex: 1,
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  createForm: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  appliesToContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 15,
  },
  criterionItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  criterionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  criterionName: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
    backgroundColor: '#f0f0f0',
  },
  statusText: {
    fontSize: 12,
    color: '#666',
  },
  criterionDetails: {
    marginBottom: 10,
  },
  detailText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  criterionActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
  actionButton: {
    padding: 5,
  },
  editForm: {
    gap: 10,
  },
  editButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\index.tsx ---
import React from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';

interface AdminMenuItem {
  id: string;
  title: string;
  icon: string;
  route: string;
}

const MENU_ITEMS: AdminMenuItem[] = [
  {
    id: 'styles',
    title: 'admin.menu.styles',
    icon: 'musical-notes',
    route: '/admin/styles',
  },
  {
    id: 'event-types',
    title: 'admin.menu.eventTypes',
    icon: 'calendar',
    route: '/admin/event-types',
  },
  {
    id: 'feedback-criteria',
    title: 'admin.menu.feedbackCriteria',
    icon: 'star',
    route: '/admin/feedback-criteria',
  },
  {
    id: 'plans',
    title: 'admin.menu.plans',
    icon: 'card',
    route: '/admin/plans',
  },
  {
    id: 'notifications',
    title: 'admin.menu.notifications',
    icon: 'notifications',
    route: '/admin/notifications',
  },
  {
    id: 'users',
    title: 'admin.menu.users',
    icon: 'people',
    route: '/admin/users',
  },
];

export default function AdminScreen() {
  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="settings" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('admin.title')}</Text>
        </View>

        <View style={styles.menuGrid}>
          {MENU_ITEMS.map((item) => (
            <TouchableOpacity
              key={item.id}
              style={styles.menuItem}
              onPress={() => router.push(item.route)}
            >
              <Ionicons name={item.icon as any} size={32} color="#007AFF" />
              <Text style={styles.menuTitle}>{i18n.t(item.title)}</Text>
            </TouchableOpacity>
          ))}
        </View>
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 30,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  menuGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    padding: 10,
  },
  menuItem: {
    width: '48%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 20,
    marginBottom: 15,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  menuTitle: {
    fontSize: 16,
    fontWeight: '500',
    marginTop: 10,
    textAlign: 'center',
    color: '#333',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\notifications.tsx ---
import React, { useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, Alert, TouchableOpacity } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { auth, db } from '../../src/services/firebase';
import { collection, addDoc, query, orderBy, getDocs } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';
import { sendPushNotification } from '../../src/services/notifications';

type NotificationTarget = 'all' | 'artist' | 'contractor';

interface AdminNotification {
  id: string;
  subject: string;
  message: string;
  target: NotificationTarget;
  createdAt: Date;
  sentBy: string;
}

export default function AdminNotificationsScreen() {
  const [notifications, setNotifications] = useState<AdminNotification[]>([]);
  const [loading, setLoading] = useState(true);
  const [sending, setSending] = useState(false);
  const [subject, setSubject] = useState('');
  const [message, setMessage] = useState('');
  const [target, setTarget] = useState<NotificationTarget>('all');

  useEffect(() => {
    loadNotifications();
  }, []);

  const loadNotifications = async () => {
    try {
      const notificationsSnapshot = await getDocs(query(
        collection(db, 'adminNotifications'),
        orderBy('createdAt', 'desc')
      ));

      const notificationsList = notificationsSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
      })) as AdminNotification[];

      setNotifications(notificationsList);
    } catch (error) {
      console.error('Error loading notifications:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleSend = async () => {
    if (!auth.currentUser || !subject.trim() || !message.trim()) return;

    setSending(true);
    try {
      // Get target users
      const usersQuery = target === 'all'
        ? query(collection(db, 'users'))
        : query(collection(db, 'users'), where('role', '==', target));

      const usersSnapshot = await getDocs(usersQuery);
      const userIds = usersSnapshot.docs.map(doc => doc.id);

      // Create admin notification record
      const notificationDoc = await addDoc(collection(db, 'adminNotifications'), {
        subject: subject.trim(),
        message: message.trim(),
        target,
        createdAt: new Date(),
        sentBy: auth.currentUser.uid,
      });

      // Create individual notifications for each user
      const notificationPromises = userIds.map(userId =>
        addDoc(collection(db, 'notifications'), {
          type: 'admin-broadcast',
          subject: subject.trim(),
          message: message.trim(),
          senderId: auth.currentUser!.uid,
          receiverId: userId,
          seen: false,
          createdAt: new Date(),
          adminNotificationId: notificationDoc.id,
        })
      );

      await Promise.all(notificationPromises);

      // Send push notifications
      const tokens = usersSnapshot.docs
        .map(doc => doc.data().pushToken)
        .filter(Boolean);

      if (tokens.length > 0) {
        await sendPushNotification(tokens, subject.trim(), message.trim(), {
          type: 'admin-broadcast',
          notificationId: notificationDoc.id,
        });
      }

      setSubject('');
      setMessage('');
      Alert.alert(i18n.t('admin.notifications.success.sent'));
      loadNotifications();
    } catch (error) {
      console.error('Error sending notifications:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setSending(false);
    }
  };

  const getTargetLabel = (target: NotificationTarget) => {
    switch (target) {
      case 'all':
        return i18n.t('admin.notifications.target.all');
      case 'artist':
        return i18n.t('admin.notifications.target.artist');
      case 'contractor':
        return i18n.t('admin.notifications.target.contractor');
      default:
        return target;
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <Ionicons name="arrow-back" size={24} color="#007AFF" />
          </TouchableOpacity>
          <View style={styles.headerContent}>
            <Ionicons name="notifications" size={32} color="#007AFF" />
            <Text style={styles.title}>{i18n.t('admin.notifications.title')}</Text>
          </View>
        </View>

        <View style={styles.form}>
          <Text style={styles.label}>{i18n.t('admin.notifications.form.subject')}</Text>
          <TextInput
            style={styles.input}
            value={subject}
            onChangeText={setSubject}
            placeholder={i18n.t('admin.notifications.form.subjectPlaceholder')}
          />

          <Text style={styles.label}>{i18n.t('admin.notifications.form.message')}</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={message}
            onChangeText={setMessage}
            multiline
            numberOfLines={4}
            placeholder={i18n.t('admin.notifications.form.messagePlaceholder')}
          />

          <Text style={styles.label}>{i18n.t('admin.notifications.form.target')}</Text>
          <View style={styles.targetButtons}>
            <Button
              title={i18n.t('admin.notifications.target.all')}
              onPress={() => setTarget('all')}
              variant={target === 'all' ? 'primary' : 'secondary'}
            />
            <Button
              title={i18n.t('admin.notifications.target.artist')}
              onPress={() => setTarget('artist')}
              variant={target === 'artist' ? 'primary' : 'secondary'}
            />
            <Button
              title={i18n.t('admin.notifications.target.contractor')}
              onPress={() => setTarget('contractor')}
              variant={target === 'contractor' ? 'primary' : 'secondary'}
            />
          </View>

          <Button
            title={i18n.t('admin.notifications.form.send')}
            onPress={handleSend}
            disabled={sending || !subject.trim() || !message.trim()}
          />
        </View>

        <View style={styles.historySection}>
          <Text style={styles.sectionTitle}>
            {i18n.t('admin.notifications.history.title')}
          </Text>

          {notifications.map((notification) => (
            <View key={notification.id} style={styles.notificationItem}>
              <View style={styles.notificationHeader}>
                <Text style={styles.notificationSubject}>
                  {notification.subject}
                </Text>
                <View style={styles.targetBadge}>
                  <Text style={styles.targetText}>
                    {getTargetLabel(notification.target)}
                  </Text>
                </View>
              </View>

              <Text style={styles.notificationMessage}>
                {notification.message}
              </Text>

              <Text style={styles.notificationTime}>
                {notification.createdAt.toLocaleString()}
              </Text>
            </View>
          ))}
        </View>
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 30,
  },
  backButton: {
    padding: 10,
  },
  headerContent: {
    flex: 1,
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  form: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  targetButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 15,
  },
  historySection: {
    marginTop: 20,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 15,
  },
  notificationItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  notificationHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  notificationSubject: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
  },
  targetBadge: {
    backgroundColor: '#E3F2FD',
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
  },
  targetText: {
    fontSize: 12,
    color: '#007AFF',
  },
  notificationMessage: {
    fontSize: 14,
    color: '#666',
    marginBottom: 10,
  },
  notificationTime: {
    fontSize: 12,
    color: '#999',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\plans.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, Alert, TouchableOpacity } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { auth, db } from '../../src/services/firebase';
import { collection, query, orderBy, getDocs, doc, setDoc, updateDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';

interface Plan {
  id: string;
  name: string;
  storageLimitMB: number;
  credits: number;
  typeEventAllowed: string[];
  price: number;
  active: boolean;
  features: string[];
  createdAt: Date;
  updatedAt: Date;
}

export default function AdminPlansScreen() {
  const [plans, setPlans] = useState<Plan[]>([]);
  const [loading, setLoading] = useState(true);
  const [newPlan, setNewPlan] = useState({
    name: '',
    storageLimitMB: 100,
    credits: 10,
    typeEventAllowed: ['SHOW'],
    price: 0,
    features: [],
  });
  const [editingPlan, setEditingPlan] = useState<Plan | null>(null);
  const [featuresInput, setFeaturesInput] = useState('');
  const [eventTypesInput, setEventTypesInput] = useState('');

  useEffect(() => {
    loadPlans();
  }, []);

  const loadPlans = async () => {
    try {
      const plansSnapshot = await getDocs(query(
        collection(db, 'plans'),
        orderBy('price', 'asc')
      ));

      const plansList = plansSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as Plan[];

      setPlans(plansList);
    } catch (error) {
      console.error('Error loading plans:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async () => {
    if (!newPlan.name.trim()) return;

    try {
      const planDoc = doc(collection(db, 'plans'));
      await setDoc(planDoc, {
        ...newPlan,
        features: featuresInput.split('\n').filter(Boolean),
        typeEventAllowed: eventTypesInput.split(',').map(t => t.trim()).filter(Boolean),
        active: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      setNewPlan({
        name: '',
        storageLimitMB: 100,
        credits: 10,
        typeEventAllowed: ['SHOW'],
        price: 0,
        features: [],
      });
      setFeaturesInput('');
      setEventTypesInput('');
      Alert.alert(i18n.t('admin.plans.success.created'));
      loadPlans();
    } catch (error) {
      console.error('Error creating plan:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleUpdate = async (plan: Plan) => {
    try {
      await updateDoc(doc(db, 'plans', plan.id), {
        name: plan.name,
        storageLimitMB: Number(plan.storageLimitMB),
        credits: Number(plan.credits),
        typeEventAllowed: plan.typeEventAllowed,
        price: Number(plan.price),
        features: plan.features,
        updatedAt: new Date(),
      });

      setEditingPlan(null);
      Alert.alert(i18n.t('admin.plans.success.updated'));
      loadPlans();
    } catch (error) {
      console.error('Error updating plan:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleToggleActive = async (plan: Plan) => {
    try {
      await updateDoc(doc(db, 'plans', plan.id), {
        active: !plan.active,
        updatedAt: new Date(),
      });

      Alert.alert(
        plan.active
          ? i18n.t('admin.plans.success.deactivated')
          : i18n.t('admin.plans.success.activated')
      );
      loadPlans();
    } catch (error) {
      console.error('Error toggling plan:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <Ionicons name="arrow-back" size={24} color="#007AFF" />
          </TouchableOpacity>
          <View style={styles.headerContent}>
            <Ionicons name="card" size={32} color="#007AFF" />
            <Text style={styles.title}>{i18n.t('admin.plans.title')}</Text>
          </View>
        </View>

        <View style={styles.createForm}>
          <Text style={styles.label}>{i18n.t('admin.plans.form.name')}</Text>
          <TextInput
            style={styles.input}
            value={newPlan.name}
            onChangeText={(text) => setNewPlan({ ...newPlan, name: text })}
            placeholder={i18n.t('admin.plans.form.namePlaceholder')}
          />

          <Text style={styles.label}>{i18n.t('admin.plans.form.storageLimit')}</Text>
          <TextInput
            style={styles.input}
            value={String(newPlan.storageLimitMB)}
            onChangeText={(text) => setNewPlan({ ...newPlan, storageLimitMB: Number(text) || 0 })}
            keyboardType="numeric"
            placeholder="MB"
          />

          <Text style={styles.label}>{i18n.t('admin.plans.form.credits')}</Text>
          <TextInput
            style={styles.input}
            value={String(newPlan.credits)}
            onChangeText={(text) => setNewPlan({ ...newPlan, credits: Number(text) || 0 })}
            keyboardType="numeric"
          />

          <Text style={styles.label}>{i18n.t('admin.plans.form.price')}</Text>
          <TextInput
            style={styles.input}
            value={String(newPlan.price)}
            onChangeText={(text) => setNewPlan({ ...newPlan, price: Number(text) || 0 })}
            keyboardType="numeric"
          />

          <Text style={styles.label}>{i18n.t('admin.plans.form.eventTypes')}</Text>
          <TextInput
            style={styles.input}
            value={eventTypesInput}
            onChangeText={setEventTypesInput}
            placeholder="SHOW, FESTIVAL"
          />

          <Text style={styles.label}>{i18n.t('admin.plans.form.features')}</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={featuresInput}
            onChangeText={setFeaturesInput}
            multiline
            numberOfLines={4}
            placeholder={i18n.t('admin.plans.form.featuresPlaceholder')}
          />

          <Button
            title={i18n.t('common.button.create')}
            onPress={handleCreate}
            disabled={!newPlan.name.trim()}
          />
        </View>

        {plans.map((plan) => (
          <View key={plan.id} style={styles.planItem}>
            {editingPlan?.id === plan.id ? (
              <View style={styles.editForm}>
                <TextInput
                  style={styles.input}
                  value={editingPlan.name}
                  onChangeText={(text) => setEditingPlan({ ...editingPlan, name: text })}
                />

                <TextInput
                  style={styles.input}
                  value={String(editingPlan.storageLimitMB)}
                  onChangeText={(text) => setEditingPlan({ ...editingPlan, storageLimitMB: Number(text) || 0 })}
                  keyboardType="numeric"
                />

                <TextInput
                  style={styles.input}
                  value={String(editingPlan.credits)}
                  onChangeText={(text) => setEditingPlan({ ...editingPlan, credits: Number(text) || 0 })}
                  keyboardType="numeric"
                />

                <TextInput
                  style={styles.input}
                  value={String(editingPlan.price)}
                  onChangeText={(text) => setEditingPlan({ ...editingPlan, price: Number(text) || 0 })}
                  keyboardType="numeric"
                />

                <TextInput
                  style={[styles.input, styles.textArea]}
                  value={editingPlan.features.join('\n')}
                  onChangeText={(text) => setEditingPlan({ ...editingPlan, features: text.split('\n').filter(Boolean) })}
                  multiline
                  numberOfLines={4}
                />

                <View style={styles.editButtons}>
                  <Button
                    title={i18n.t('common.button.save')}
                    onPress={() => handleUpdate(editingPlan)}
                  />
                  <Button
                    title={i18n.t('common.button.cancel')}
                    onPress={() => setEditingPlan(null)}
                    variant="secondary"
                  />
                </View>
              </View>
            ) : (
              <>
                <View style={styles.planHeader}>
                  <Text style={styles.planName}>{plan.name}</Text>
                  <View style={styles.statusBadge}>
                    <Text style={styles.statusText}>
                      {plan.active
                        ? i18n.t('admin.plans.status.active')
                        : i18n.t('admin.plans.status.inactive')}
                    </Text>
                  </View>
                </View>

                <View style={styles.planDetails}>
                  <Text style={styles.detailText}>
                    {i18n.t('admin.plans.storage')}: {plan.storageLimitMB}MB
                  </Text>
                  <Text style={styles.detailText}>
                    {i18n.t('admin.plans.credits')}: {plan.credits}
                  </Text>
                  <Text style={styles.detailText}>
                    {i18n.t('admin.plans.price')}: ${plan.price}
                  </Text>
                  <Text style={styles.detailText}>
                    {i18n.t('admin.plans.eventTypes')}: {plan.typeEventAllowed.join(', ')}
                  </Text>
                </View>

                <View style={styles.featuresList}>
                  {plan.features.map((feature, index) => (
                    <View key={index} style={styles.featureItem}>
                      <Ionicons name="checkmark-circle" size={20} color="#4CAF50" />
                      <Text style={styles.featureText}>{feature}</Text>
                    </View>
                  ))}
                </View>

                <View style={styles.planActions}>
                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => setEditingPlan(plan)}
                  >
                    <Ionicons name="create-outline" size={24} color="#007AFF" />
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => handleToggleActive(plan)}
                  >
                    <Ionicons
                      name={plan.active ? "eye-off-outline" : "eye-outline"}
                      size={24}
                      color={plan.active ? "#F44336" : "#4CAF50"}
                    />
                  </TouchableOpacity>
                </View>
              </>
            )}
          </View>
        ))}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 30,
  },
  backButton: {
    padding: 10,
  },
  headerContent: {
    flex: 1,
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  createForm: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  planItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  planHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  planName: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
    backgroundColor: '#f0f0f0',
  },
  statusText: {
    fontSize: 12,
    color: '#666',
  },
  planDetails: {
    marginBottom: 15,
  },
  detailText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  featuresList: {
    marginBottom: 15,
  },
  featureItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 5,
  },
  featureText: {
    marginLeft: 10,
    fontSize: 14,
    color: '#333',
  },
  planActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
  actionButton: {
    padding: 5,
  },
  editForm: {
    gap: 10,
  },
  editButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\styles.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, Alert, TouchableOpacity } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { auth, db } from '../../src/services/firebase';
import { collection, query, orderBy, getDocs, doc, setDoc, updateDoc, deleteDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';

interface MusicStyle {
  id: string;
  name: string;
  active: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export default function AdminStylesScreen() {
  const [styles, setStyles] = useState<MusicStyle[]>([]);
  const [loading, setLoading] = useState(true);
  const [newStyleName, setNewStyleName] = useState('');
  const [editingStyle, setEditingStyle] = useState<MusicStyle | null>(null);

  useEffect(() => {
    loadStyles();
  }, []);

  const loadStyles = async () => {
    try {
      const stylesSnapshot = await getDocs(query(
        collection(db, 'styles'),
        orderBy('name', 'asc')
      ));

      const stylesList = stylesSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as MusicStyle[];

      setStyles(stylesList);
    } catch (error) {
      console.error('Error loading styles:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async () => {
    if (!newStyleName.trim()) return;

    try {
      const styleDoc = doc(collection(db, 'styles'));
      await setDoc(styleDoc, {
        name: newStyleName.trim(),
        active: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      setNewStyleName('');
      Alert.alert(i18n.t('admin.styles.success.created'));
      loadStyles();
    } catch (error) {
      console.error('Error creating style:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleUpdate = async (style: MusicStyle) => {
    try {
      await updateDoc(doc(db, 'styles', style.id), {
        name: style.name,
        active: style.active,
        updatedAt: new Date(),
      });

      setEditingStyle(null);
      Alert.alert(i18n.t('admin.styles.success.updated'));
      loadStyles();
    } catch (error) {
      console.error('Error updating style:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleToggleActive = async (style: MusicStyle) => {
    try {
      await updateDoc(doc(db, 'styles', style.id), {
        active: !style.active,
        updatedAt: new Date(),
      });

      Alert.alert(
        style.active
          ? i18n.t('admin.styles.success.deactivated')
          : i18n.t('admin.styles.success.activated')
      );
      loadStyles();
    } catch (error) {
      console.error('Error toggling style:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleDelete = async (style: MusicStyle) => {
    Alert.alert(
      i18n.t('admin.styles.delete.title'),
      i18n.t('admin.styles.delete.message'),
      [
        {
          text: i18n.t('common.button.cancel'),
          style: 'cancel',
        },
        {
          text: i18n.t('common.button.confirm'),
          style: 'destructive',
          onPress: async () => {
            try {
              await updateDoc(doc(db, 'styles', style.id), {
                active: false,
                deletedAt: new Date(),
              });

              Alert.alert(i18n.t('admin.styles.success.deleted'));
              loadStyles();
            } catch (error) {
              console.error('Error deleting style:', error);
              Alert.alert(i18n.t('common.error.unknown'));
            }
          },
        },
      ]
    );
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <Ionicons name="arrow-back" size={24} color="#007AFF" />
          </TouchableOpacity>
          <View style={styles.headerContent}>
            <Ionicons name="musical-notes" size={32} color="#007AFF" />
            <Text style={styles.title}>{i18n.t('admin.styles.title')}</Text>
          </View>
        </View>

        <View style={styles.createForm}>
          <Text style={styles.label}>{i18n.t('admin.styles.form.name')}</Text>
          <View style={styles.inputContainer}>
            <TextInput
              style={styles.input}
              value={newStyleName}
              onChangeText={setNewStyleName}
              placeholder={i18n.t('admin.styles.form.namePlaceholder')}
            />
            <Button
              title={i18n.t('common.button.create')}
              onPress={handleCreate}
              disabled={!newStyleName.trim()}
            />
          </View>
        </View>

        {styles.map((style) => (
          <View key={style.id} style={styles.styleItem}>
            {editingStyle?.id === style.id ? (
              <View style={styles.editForm}>
                <TextInput
                  style={styles.input}
                  value={editingStyle.name}
                  onChangeText={(text) => setEditingStyle({ ...editingStyle, name: text })}
                />
                <View style={styles.editButtons}>
                  <Button
                    title={i18n.t('common.button.save')}
                    onPress={() => handleUpdate(editingStyle)}
                  />
                  <Button
                    title={i18n.t('common.button.cancel')}
                    onPress={() => setEditingStyle(null)}
                    variant="secondary"
                  />
                </View>
              </View>
            ) : (
              <>
                <View style={styles.styleHeader}>
                  <Text style={styles.styleName}>{style.name}</Text>
                  <View style={styles.statusBadge}>
                    <Text style={styles.statusText}>
                      {style.active
                        ? i18n.t('admin.styles.status.active')
                        : i18n.t('admin.styles.status.inactive')}
                    </Text>
                  </View>
                </View>

                <View style={styles.styleActions}>
                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => setEditingStyle(style)}
                  >
                    <Ionicons name="create-outline" size={24} color="#007AFF" />
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => handleToggleActive(style)}
                  >
                    <Ionicons
                      name={style.active ? "eye-off-outline" : "eye-outline"}
                      size={24}
                      color={style.active ? "#F44336" : "#4CAF50"}
                    />
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => handleDelete(style)}
                  >
                    <Ionicons name="trash-outline" size={24} color="#F44336" />
                  </TouchableOpacity>
                </View>
              </>
            )}
          </View>
        ))}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 30,
  },
  backButton: {
    padding: 10,
  },
  headerContent: {
    flex: 1,
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  createForm: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  inputContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  input: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  styleItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  styleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  styleName: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
    backgroundColor: '#f0f0f0',
  },
  statusText: {
    fontSize: 12,
    color: '#666',
  },
  styleActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
  actionButton: {
    padding: 5,
  },
  editForm: {
    gap: 10,
  },
  editButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\users.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, Alert, TouchableOpacity } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { auth, db } from '../../src/services/firebase';
import { collection, query, orderBy, getDocs, doc, updateDoc } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';
import { UserRating } from '../../src/components/UserRating';
import type { User } from '../../src/types';

export default function AdminUsersScreen() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterRole, setFilterRole] = useState<'all' | 'artist' | 'contractor'>('all');
  const [filterPlan, setFilterPlan] = useState<'all' | 'free' | 'paid'>('all');
  const [sortBy, setSortBy] = useState<'email' | 'rating' | 'createdAt'>('createdAt');

  useEffect(() => {
    loadUsers();
  }, []);

  const loadUsers = async () => {
    try {
      const usersSnapshot = await getDocs(query(
        collection(db, 'users'),
        orderBy('createdAt', 'desc')
      ));

      const usersList = usersSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
      })) as User[];

      setUsers(usersList);
    } catch (error) {
      console.error('Error loading users:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleToggleAdmin = async (user: User) => {
    try {
      await updateDoc(doc(db, 'users', user.id), {
        isAdmin: !user.isAdmin,
        updatedAt: new Date(),
      });

      Alert.alert(
        user.isAdmin
          ? i18n.t('admin.users.success.adminRemoved')
          : i18n.t('admin.users.success.adminAdded')
      );
      loadUsers();
    } catch (error) {
      console.error('Error toggling admin status:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleToggleActive = async (user: User) => {
    try {
      await updateDoc(doc(db, 'users', user.id), {
        active: !user.active,
        updatedAt: new Date(),
      });

      Alert.alert(
        user.active
          ? i18n.t('admin.users.success.deactivated')
          : i18n.t('admin.users.success.activated')
      );
      loadUsers();
    } catch (error) {
      console.error('Error toggling user status:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleResetCredits = async (user: User) => {
    try {
      await updateDoc(doc(db, 'users', user.id), {
        credits: user.planId === 'free' ? 10 : -1,
        updatedAt: new Date(),
      });

      Alert.alert(i18n.t('admin.users.success.creditsReset'));
      loadUsers();
    } catch (error) {
      console.error('Error resetting credits:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const filteredUsers = users
    .filter(user => {
      const matchesSearch = user.email.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesRole = filterRole === 'all' || user.role === filterRole;
      const matchesPlan = filterPlan === 'all' || user.planId === filterPlan;
      return matchesSearch && matchesRole && matchesPlan;
    })
    .sort((a, b) => {
      switch (sortBy) {
        case 'email':
          return a.email.localeCompare(b.email);
        case 'rating':
          return (b.rating || 0) - (a.rating || 0);
        case 'createdAt':
          return b.createdAt.getTime() - a.createdAt.getTime();
        default:
          return 0;
      }
    });

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <Ionicons name="arrow-back" size={24} color="#007AFF" />
          </TouchableOpacity>
          <View style={styles.headerContent}>
            <Ionicons name="people" size={32} color="#007AFF" />
            <Text style={styles.title}>{i18n.t('admin.users.title')}</Text>
          </View>
        </View>

        <View style={styles.filters}>
          <TextInput
            style={styles.searchInput}
            value={searchTerm}
            onChangeText={setSearchTerm}
            placeholder={i18n.t('admin.users.search')}
          />

          <View style={styles.filterButtons}>
            <View style={styles.filterGroup}>
              <Text style={styles.filterLabel}>{i18n.t('admin.users.filterRole')}</Text>
              <View style={styles.buttonGroup}>
                <Button
                  title={i18n.t('admin.users.roles.all')}
                  onPress={() => setFilterRole('all')}
                  variant={filterRole === 'all' ? 'primary' : 'secondary'}
                />
                <Button
                  title={i18n.t('admin.users.roles.artist')}
                  onPress={() => setFilterRole('artist')}
                  variant={filterRole === 'artist' ? 'primary' : 'secondary'}
                />
                <Button
                  title={i18n.t('admin.users.roles.contractor')}
                  onPress={() => setFilterRole('contractor')}
                  variant={filterRole === 'contractor' ? 'primary' : 'secondary'}
                />
              </View>
            </View>

            <View style={styles.filterGroup}>
              <Text style={styles.filterLabel}>{i18n.t('admin.users.filterPlan')}</Text>
              <View style={styles.buttonGroup}>
                <Button
                  title={i18n.t('admin.users.plans.all')}
                  onPress={() => setFilterPlan('all')}
                  variant={filterPlan === 'all' ? 'primary' : 'secondary'}
                />
                <Button
                  title={i18n.t('admin.users.plans.free')}
                  onPress={() => setFilterPlan('free')}
                  variant={filterPlan === 'free' ? 'primary' : 'secondary'}
                />
                <Button
                  title={i18n.t('admin.users.plans.paid')}
                  onPress={() => setFilterPlan('paid')}
                  variant={filterPlan === 'paid' ? 'primary' : 'secondary'}
                />
              </View>
            </View>

            <View style={styles.filterGroup}>
              <Text style={styles.filterLabel}>{i18n.t('admin.users.sortBy')}</Text>
              <View style={styles.buttonGroup}>
                <Button
                  title={i18n.t('admin.users.sort.email')}
                  onPress={() => setSortBy('email')}
                  variant={sortBy === 'email' ? 'primary' : 'secondary'}
                />
                <Button
                  title={i18n.t('admin.users.sort.rating')}
                  onPress={() => setSortBy('rating')}
                  variant={sortBy === 'rating' ? 'primary' : 'secondary'}
                />
                <Button
                  title={i18n.t('admin.users.sort.date')}
                  onPress={() => setSortBy('createdAt')}
                  variant={sortBy === 'createdAt' ? 'primary' : 'secondary'}
                />
              </View>
            </View>
          </View>
        </View>

        {filteredUsers.map((user) => (
          <View key={user.id} style={styles.userItem}>
            <View style={styles.userHeader}>
              <View style={styles.userInfo}>
                <Text style={styles.userEmail}>{user.email}</Text>
                <View style={styles.badges}>
                  <View style={[styles.badge, styles.roleBadge]}>
                    <Text style={styles.badgeText}>
                      {i18n.t(`admin.users.roles.${user.role}`)}
                    </Text>
                  </View>
                  <View style={[styles.badge, styles.planBadge]}>
                    <Text style={styles.badgeText}>
                      {i18n.t(`admin.users.plans.${user.planId}`)}
                    </Text>
                  </View>
                  {user.isAdmin && (
                    <View style={[styles.badge, styles.adminBadge]}>
                      <Text style={styles.badgeText}>
                        {i18n.t('admin.users.badges.admin')}
                      </Text>
                    </View>
                  )}
                  {!user.active && (
                    <View style={[styles.badge, styles.inactiveBadge]}>
                      <Text style={styles.badgeText}>
                        {i18n.t('admin.users.badges.inactive')}
                      </Text>
                    </View>
                  )}
                </View>
              </View>
              {user.rating !== undefined && (
                <UserRating rating={user.rating} reviewCount={user.reviewCount || 0} />
              )}
            </View>

            <View style={styles.userDetails}>
              <Text style={styles.detailText}>
                {i18n.t('admin.users.credits')}: {user.credits || 0}
              </Text>
              <Text style={styles.detailText}>
                {i18n.t('admin.users.storage')}: {user.bucketUse || 0}MB
              </Text>
              <Text style={styles.detailText}>
                {i18n.t('admin.users.joined')}: {user.createdAt.toLocaleDateString()}
              </Text>
            </View>

            <View style={styles.userActions}>
              <TouchableOpacity
                style={styles.actionButton}
                onPress={() => handleToggleAdmin(user)}
              >
                <Ionicons
                  name={user.isAdmin ? "shield-off" : "shield"}
                  size={24}
                  color="#007AFF"
                />
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.actionButton}
                onPress={() => handleToggleActive(user)}
              >
                <Ionicons
                  name={user.active ? "eye-off-outline" : "eye-outline"}
                  size={24}
                  color={user.active ? "#F44336" : "#4CAF50"}
                />
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.actionButton}
                onPress={() => handleResetCredits(user)}
              >
                <Ionicons name="refresh" size={24} color="#FF9800" />
              </TouchableOpacity>
            </View>
          </View>
        ))}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 30,
  },
  backButton: {
    padding: 10,
  },
  headerContent: {
    flex: 1,
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  filters: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  searchInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  filterButtons: {
    gap: 15,
  },
  filterGroup: {
    gap: 10,
  },
  filterLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  buttonGroup: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 10,
  },
  userItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  userHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 10,
  },
  userInfo: {
    flex: 1,
  },
  userEmail: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 5,
  },
  badges: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 5,
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  roleBadge: {
    backgroundColor: '#E3F2FD',
  },
  planBadge: {
    backgroundColor: '#E8F5E9',
  },
  adminBadge: {
    backgroundColor: '#FFF3E0',
  },
  inactiveBadge: {
    backgroundColor: '#FFEBEE',
  },
  badgeText: {
    fontSize: 12,
    fontWeight: 'bold',
  },
  userDetails: {
    marginBottom: 15,
  },
  detailText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  userActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
  actionButton: {
    padding: 5,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\admin\_layout.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ActivityIndicator } from 'react-native';
import { Stack } from 'expo-router';
import { auth, db } from '../../src/services/firebase';
import { doc, getDoc } from 'firebase/firestore';
import { AdminGuard } from '../../src/components/AdminGuard';

export default function AdminLayout() {
  const [loading, setLoading] = useState(true);
  const [isAdmin, setIsAdmin] = useState(false);

  useEffect(() => {
    checkAdminStatus();
  }, []);

  const checkAdminStatus = async () => {
    if (!auth.currentUser) {
      setLoading(false);
      return;
    }

    try {
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      setIsAdmin(userDoc.exists() && userDoc.data()?.isAdmin === true);
    } catch (error) {
      console.error('Error checking admin status:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#007AFF" />
      </View>
    );
  }

  return (
    <AdminGuard isAdmin={isAdmin}>
      <Stack>
        <Stack.Screen
          name="index"
          options={{
            title: 'Admin Panel',
            headerShown: false,
          }}
        />
        <Stack.Screen
          name="styles"
          options={{
            title: 'Musical Styles',
            headerShown: false,
          }}
        />
        <Stack.Screen
          name="event-types"
          options={{
            title: 'Event Types',
            headerShown: false,
          }}
        />
        <Stack.Screen
          name="feedback-criteria"
          options={{
            title: 'Feedback Criteria',
            headerShown: false,
          }}
        />
        <Stack.Screen
          name="plans"
          options={{
            title: 'Plans',
            headerShown: false,
          }}
        />
        <Stack.Screen
          name="notifications"
          options={{
            title: 'Notifications',
            headerShown: false,
          }}
        />
        <Stack.Screen
          name="users"
          options={{
            title: 'Users',
            headerShown: false,
          }}
        />
      </Stack>
    </AdminGuard>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\chat\[id].tsx ---
import React, { useEffect, useState, useRef } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, TouchableOpacity, Alert } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { auth, db } from '../../src/services/firebase';
import { collection, query, where, orderBy, getDocs, addDoc, doc, getDoc, updateDoc, increment } from 'firebase/firestore';
import { useLocalSearchParams } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';
import type { Message, Chat, User } from '../../src/types';

const FREE_PLAN_DAILY_MESSAGES = 20;

export default function ChatScreen() {
  const { id: chatId } = useLocalSearchParams<{ id: string }>();
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState('');
  const [loading, setLoading] = useState(true);
  const [chat, setChat] = useState<Chat | null>(null);
  const [otherUser, setOtherUser] = useState<User | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const scrollViewRef = useRef<ScrollView>(null);

  useEffect(() => {
    loadChat();
    const interval = setInterval(loadMessages, 5000); // Poll for new messages
    return () => clearInterval(interval);
  }, [chatId]);

  const loadChat = async () => {
    if (!auth.currentUser || !chatId) return;

    try {
      const [chatDoc, userDoc] = await Promise.all([
        getDoc(doc(db, 'chats', chatId)),
        getDoc(doc(db, 'users', auth.currentUser.uid))
      ]);

      if (chatDoc.exists()) {
        const chatData = { id: chatDoc.id, ...chatDoc.data() } as Chat;
        setChat(chatData);

        // Get other participant
        const otherUserId = chatData.participants.find(id => id !== auth.currentUser?.uid);
        if (otherUserId) {
          const otherUserDoc = await getDoc(doc(db, 'users', otherUserId));
          if (otherUserDoc.exists()) {
            setOtherUser(otherUserDoc.data() as User);
          }
        }
      }

      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }

      await loadMessages();
    } catch (error) {
      console.error('Error loading chat:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const loadMessages = async () => {
    if (!chatId) return;

    try {
      const messagesSnapshot = await getDocs(query(
        collection(db, `chats/${chatId}/messages`),
        orderBy('createdAt', 'asc')
      ));

      const messagesList = messagesSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
      })) as Message[];

      setMessages(messagesList);
      scrollViewRef.current?.scrollToEnd({ animated: true });
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const handleSend = async () => {
    if (!auth.currentUser || !chatId || !newMessage.trim()) return;

    try {
      if (user?.planId === 'free') {
        const messagesSent = user.messagesSentToday || 0;
        if (messagesSent >= FREE_PLAN_DAILY_MESSAGES) {
          Alert.alert(i18n.t('chat.error.dailyLimit'));
          return;
        }

        // Update messages sent count
        await updateDoc(doc(db, 'users', auth.currentUser.uid), {
          messagesSentToday: increment(1)
        });
      }

      // Add message
      const message = {
        senderId: auth.currentUser.uid,
        text: newMessage.trim(),
        createdAt: new Date(),
      };

      await addDoc(collection(db, `chats/${chatId}/messages`), message);

      // Create notification for other user
      const otherUserId = chat?.participants.find(id => id !== auth.currentUser?.uid);
      if (otherUserId) {
        await addDoc(collection(db, 'notifications'), {
          type: 'chat',
          chatId,
          senderId: auth.currentUser.uid,
          receiverId: otherUserId,
          seen: false,
          createdAt: new Date(),
        });
      }

      setNewMessage('');
      await loadMessages();
    } catch (error) {
      console.error('Error sending message:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  return (
    <Layout>
      <View style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="chatbubbles" size={32} color="#007AFF" />
          <Text style={styles.title}>
            {otherUser?.email || i18n.t('chat.title')}
          </Text>
        </View>

        <ScrollView
          ref={scrollViewRef}
          style={styles.messagesContainer}
          onContentSizeChange={() => scrollViewRef.current?.scrollToEnd({ animated: true })}
        >
          {messages.map((message) => (
            <View
              key={message.id}
              style={[
                styles.messageBox,
                message.senderId === auth.currentUser?.uid
                  ? styles.sentMessage
                  : styles.receivedMessage
              ]}
            >
              <Text style={styles.messageText}>{message.text}</Text>
              <Text style={styles.messageTime}>
                {message.createdAt.toLocaleTimeString()}
              </Text>
            </View>
          ))}
        </ScrollView>

        <View style={styles.inputContainer}>
          <TextInput
            style={styles.input}
            value={newMessage}
            onChangeText={setNewMessage}
            placeholder={i18n.t('chat.placeholder')}
            multiline
          />
          <TouchableOpacity
            style={styles.sendButton}
            onPress={handleSend}
            disabled={!newMessage.trim()}
          >
            <Ionicons
              name="send"
              size={24}
              color={newMessage.trim() ? "#007AFF" : "#999"}
            />
          </TouchableOpacity>
        </View>
      </View>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  messagesContainer: {
    flex: 1,
    paddingHorizontal: 15,
  },
  messageBox: {
    maxWidth: '80%',
    padding: 10,
    borderRadius: 8,
    marginBottom: 10,
  },
  sentMessage: {
    alignSelf: 'flex-end',
    backgroundColor: '#007AFF',
  },
  receivedMessage: {
    alignSelf: 'flex-start',
    backgroundColor: '#E5E5EA',
  },
  messageText: {
    fontSize: 16,
    color: '#FFFFFF',
  },
  messageTime: {
    fontSize: 12,
    color: '#FFFFFF80',
    marginTop: 5,
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 10,
    borderTopWidth: 1,
    borderTopColor: '#E5E5EA',
    backgroundColor: '#FFFFFF',
  },
  input: {
    flex: 1,
    backgroundColor: '#F0F0F0',
    borderRadius: 20,
    paddingHorizontal: 15,
    paddingVertical: 10,
    marginRight: 10,
    fontSize: 16,
  },
  sendButton: {
    width: 44,
    height: 44,
    alignItems: 'center',
    justifyContent: 'center',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\events\create.tsx ---
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, StyleSheet, ScrollView, Alert } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { Picker } from '@react-native-picker/picker';
import { auth, db } from '../../src/services/firebase';
import { collection, addDoc, doc, getDoc, updateDoc, increment } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';
import type { EventType, User } from '../../src/types';

export default function CreateEventScreen() {
  const [title, setTitle] = useState('');
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');
  const [location, setLocation] = useState('');
  const [eventType, setEventType] = useState<EventType>('SHOW');
  const [minCache, setMinCache] = useState('');
  const [maxCache, setMaxCache] = useState('');
  const [stylesInput, setStylesInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    loadUser();
  }, []);

  const loadUser = async () => {
    if (!auth.currentUser) return;

    try {
      const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
      if (userDoc.exists()) {
        setUser(userDoc.data() as User);
      }
    } catch (error) {
      console.error('Error loading user:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const validateForm = () => {
    if (!title || !startDate || !endDate || !location) {
      Alert.alert(i18n.t('events.error.requiredFields'));
      return false;
    }

    if (user?.planId === 'free') {
      if (eventType !== 'SHOW') {
        Alert.alert(i18n.t('events.error.eventTypeRestricted'));
        return false;
      }

      const styles = stylesInput.split(',').map(s => s.trim()).filter(Boolean);
      if (styles.length > 1) {
        Alert.alert(i18n.t('events.error.styleLimit'));
        return false;
      }
    }

    return true;
  };

  const handleCreate = async () => {
    if (!auth.currentUser || !validateForm()) return;

    setLoading(true);
    try {
      const styles = stylesInput.split(',').map(s => s.trim()).filter(Boolean);
      
      const eventData = {
        creatorId: auth.currentUser.uid,
        title,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        location,
        eventType,
        minCache: Number(minCache) || 0,
        maxCache: Number(maxCache) || 0,
        styles,
        status: 'ABERTO',
        createdAt: new Date(),
      };

      await addDoc(collection(db, 'events'), eventData);

      if (user?.planId === 'free') {
        await updateDoc(doc(db, 'users', auth.currentUser.uid), {
          credits: increment(-1)
        });
      }

      Alert.alert(i18n.t('events.success.created'));
      router.back();
    } catch (error) {
      console.error('Error creating event:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="create" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('events.create.title')}</Text>
        </View>

        <View style={styles.form}>
          <Text style={styles.label}>{i18n.t('events.form.title')}</Text>
          <TextInput
            style={styles.input}
            value={title}
            onChangeText={setTitle}
          />

          <Text style={styles.label}>{i18n.t('events.form.startDate')}</Text>
          <TextInput
            style={styles.input}
            value={startDate}
            onChangeText={setStartDate}
            placeholder="YYYY-MM-DD HH:mm"
          />

          <Text style={styles.label}>{i18n.t('events.form.endDate')}</Text>
          <TextInput
            style={styles.input}
            value={endDate}
            onChangeText={setEndDate}
            placeholder="YYYY-MM-DD HH:mm"
          />

          <Text style={styles.label}>{i18n.t('events.form.location')}</Text>
          <TextInput
            style={styles.input}
            value={location}
            onChangeText={setLocation}
          />

          <Text style={styles.label}>{i18n.t('events.form.eventType')}</Text>
          <Picker
            selectedValue={eventType}
            onValueChange={(value) => setEventType(value as EventType)}
            style={styles.picker}
            enabled={user?.planId === 'paid'}
          >
            <Picker.Item label={i18n.t('events.type.show')} value="SHOW" />
            {user?.planId === 'paid' && (
              <Picker.Item label={i18n.t('events.type.festival')} value="FESTIVAL" />
            )}
          </Picker>

          <Text style={styles.label}>{i18n.t('events.form.cache')}</Text>
          <View style={styles.cacheContainer}>
            <TextInput
              style={[styles.input, styles.cacheInput]}
              value={minCache}
              onChangeText={setMinCache}
              keyboardType="numeric"
              placeholder={i18n.t('events.form.minCache')}
            />
            <TextInput
              style={[styles.input, styles.cacheInput]}
              value={maxCache}
              onChangeText={setMaxCache}
              keyboardType="numeric"
              placeholder={i18n.t('events.form.maxCache')}
              editable={user?.planId === 'paid'}
            />
          </View>

          <Text style={styles.label}>
            {i18n.t('events.form.styles')}
            {user?.planId === 'free' && (
              <Text style={styles.planLimit}> (máx. 1)</Text>
            )}
          </Text>
          <TextInput
            style={styles.input}
            value={stylesInput}
            onChangeText={setStylesInput}
            placeholder="Rock, Pop, Jazz"
          />
        </View>

        <Button
          title={i18n.t('events.create.submit')}
          onPress={handleCreate}
          disabled={loading}
        />
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  form: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  planLimit: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 15,
    marginBottom: 15,
    borderRadius: 8,
    fontSize: 16,
  },
  picker: {
    marginBottom: 15,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
  },
  cacheContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  cacheInput: {
    flex: 1,
    marginHorizontal: 5,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\events\index.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert } from 'react-native';
import { Layout } from '../../src/components/Layout';
import { Button } from '../../src/components/Button';
import { EventList } from '../../src/components/EventList';
import { auth, db } from '../../src/services/firebase';
import { collection, query, where, orderBy, getDocs } from 'firebase/firestore';
import { router } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../src/i18n';
import type { Event, User } from '../../src/types';

export default function EventsScreen() {
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    loadEvents();
  }, []);

  const loadEvents = async () => {
    if (!auth.currentUser) return;

    try {
      const [userDoc, eventsSnapshot] = await Promise.all([
        getDocs(query(collection(db, 'users'), where('id', '==', auth.currentUser.uid))),
        getDocs(query(
          collection(db, 'events'),
          where('creatorId', '==', auth.currentUser.uid),
          orderBy('createdAt', 'desc')
        ))
      ]);

      if (!userDoc.empty) {
        setUser(userDoc.docs[0].data() as User);
      }

      const eventsList = eventsSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as Event[];

      setEvents(eventsList);
    } catch (error) {
      console.error('Error loading events:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleCreateEvent = () => {
    if (user?.planId === 'free' && (user?.credits || 0) < 1) {
      Alert.alert(i18n.t('events.error.noCredits'));
      return;
    }
    router.push('/events/create');
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="calendar" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('events.title')}</Text>
        </View>

        <Button
          title={i18n.t('events.createButton')}
          onPress={handleCreateEvent}
        />

        <EventList
          events={events}
          onUpdate={loadEvents}
          isPaidPlan={user?.planId === 'paid'}
        />
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\app\events\[id]\candidacies.tsx ---
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, Alert, TouchableOpacity } from 'react-native';
import { Layout } from '../../../src/components/Layout';
import { auth, db } from '../../../src/services/firebase';
import { collection, query, where, getDocs, doc, getDoc, updateDoc, addDoc } from 'firebase/firestore';
import { useLocalSearchParams } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import i18n from '../../../src/i18n';
import type { Candidacy, Event, User, AvailabilityBlock } from '../../../src/types';

export default function EventCandidaciesScreen() {
  const { id: eventId } = useLocalSearchParams<{ id: string }>();
  const [candidacies, setCandidacies] = useState<(Candidacy & { artist: User })[]>([]);
  const [event, setEvent] = useState<Event | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadCandidacies();
  }, [eventId]);

  const loadCandidacies = async () => {
    if (!auth.currentUser || !eventId) return;

    try {
      // Load event details
      const eventDoc = await getDoc(doc(db, 'events', eventId));
      if (eventDoc.exists()) {
        setEvent(eventDoc.data() as Event);
      }

      // Load candidacies
      const candidaciesSnapshot = await getDocs(query(
        collection(db, 'candidacies'),
        where('eventId', '==', eventId)
      ));

      const candidaciesWithArtists = await Promise.all(
        candidaciesSnapshot.docs.map(async (doc) => {
          const candidacy = { id: doc.id, ...doc.data() } as Candidacy;
          const artistDoc = await getDoc(doc(db, 'users', candidacy.artistId));
          return {
            ...candidacy,
            artist: artistDoc.data() as User,
          };
        })
      );

      setCandidacies(candidaciesWithArtists);
    } catch (error) {
      console.error('Error loading candidacies:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    } finally {
      setLoading(false);
    }
  };

  const handleUpdateStatus = async (candidacy: Candidacy, newStatus: 'APROVADA' | 'REJEITADA') => {
    try {
      await updateDoc(doc(db, 'candidacies', candidacy.id), {
        status: newStatus
      });

      if (newStatus === 'APROVADA') {
        // Create BUSY block in artist's agenda
        if (event) {
          await addDoc(collection(db, 'artistAgenda'), {
            artistId: candidacy.artistId,
            startDate: event.startDate,
            endDate: event.endDate,
            status: 'BUSY',
            eventId: event.id,
            createdAt: new Date(),
          });
        }

        if (event?.eventType === 'SHOW') {
          await updateDoc(doc(db, 'events', eventId), {
            status: 'ENCERRADO'
          });
        }
      }

      Alert.alert(
        i18n.t('events.success.statusUpdated'),
        newStatus === 'APROVADA' 
          ? i18n.t('events.success.approved')
          : i18n.t('events.success.rejected')
      );

      loadCandidacies();
    } catch (error) {
      console.error('Error updating candidacy:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  return (
    <Layout>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="people" size={32} color="#007AFF" />
          <Text style={styles.title}>{i18n.t('events.candidacies.title')}</Text>
        </View>

        {candidacies.map((candidacy) => (
          <View key={candidacy.id} style={styles.candidacyItem}>
            <View style={styles.candidacyHeader}>
              <Text style={styles.artistName}>{candidacy.artist.email}</Text>
              <View style={[styles.statusBadge, styles[`status${candidacy.status}`]]}>
                <Text style={styles.statusText}>
                  {i18n.t(`events.candidacies.status.${candidacy.status.toLowerCase()}`)}
                </Text>
              </View>
            </View>

            {candidacy.status === 'PENDENTE' && (
              <View style={styles.actions}>
                <TouchableOpacity
                  style={[styles.actionButton, styles.approveButton]}
                  onPress={() => handleUpdateStatus(candidacy, 'APROVADA')}
                >
                  <Ionicons name="checkmark-circle" size={24} color="#4CAF50" />
                  <Text style={[styles.actionText, styles.approveText]}>
                    {i18n.t('events.candidacies.approve')}
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.actionButton, styles.rejectButton]}
                  onPress={() => handleUpdateStatus(candidacy, 'REJEITADA')}
                >
                  <Ionicons name="close-circle" size={24} color="#F44336" />
                  <Text style={[styles.actionText, styles.rejectText]}>
                    {i18n.t('events.candidacies.reject')}
                  </Text>
                </TouchableOpacity>
              </View>
            )}
          </View>
        ))}
      </ScrollView>
    </Layout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 10,
  },
  candidacyItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  candidacyHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  artistName: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
  },
  statusPENDENTE: {
    backgroundColor: '#FFC107',
  },
  statusAPROVADA: {
    backgroundColor: '#4CAF50',
  },
  statusREJEITADA: {
    backgroundColor: '#F44336',
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 10,
  },
  actionButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 10,
    borderRadius: 8,
    marginHorizontal: 5,
  },
  approveButton: {
    backgroundColor: '#E8F5E9',
  },
  rejectButton: {
    backgroundColor: '#FFEBEE',
  },
  actionText: {
    marginLeft: 5,
    fontSize: 14,
    fontWeight: 'bold',
  },
  approveText: {
    color: '#4CAF50',
  },
  rejectText: {
    color: '#F44336',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\AdminGuard.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { router } from 'expo-router';
import { Button } from './Button';
import i18n from '../i18n';

interface AdminGuardProps {
  children: React.ReactNode;
  isAdmin: boolean;
}

export function AdminGuard({ children, isAdmin }: AdminGuardProps) {
  if (!isAdmin) {
    return (
      <View style={styles.container}>
        <Text style={styles.title}>{i18n.t('admin.accessDenied')}</Text>
        <Text style={styles.message}>{i18n.t('admin.notAuthorized')}</Text>
        <Button
          title={i18n.t('common.button.back')}
          onPress={() => router.back()}
          variant="secondary"
        />
      </View>
    );
  }

  return <>{children}</>;
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#F44336',
  },
  message: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\Button.tsx ---
import React from 'react';
import { TouchableOpacity, Text, StyleSheet } from 'react-native';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
}

export const Button = ({ title, onPress, variant = 'primary' }: ButtonProps) => {
  return (
    <TouchableOpacity
      style={[styles.button, variant === 'secondary' && styles.buttonSecondary]}
      onPress={onPress}
    >
      <Text style={[styles.text, variant === 'secondary' && styles.textSecondary]}>
        {title}
      </Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    backgroundColor: '#007AFF',
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  buttonSecondary: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#007AFF',
  },
  text: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  textSecondary: {
    color: '#007AFF',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\ErrorBoundary.tsx ---
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Button } from './Button';
import i18n from '../i18n';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.container}>
          <Text style={styles.title}>{i18n.t('common.error.unknown')}</Text>
          <Button
            title="Try Again"
            onPress={() => this.setState({ hasError: false })}
          />
        </View>
      );
    }

    return this.props.children;
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\EventList.tsx ---
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import i18n from '../i18n';
import type { Event } from '../types';

interface EventListProps {
  events: Event[];
  onUpdate: () => void;
  isPaidPlan: boolean;
}

export function EventList({ events, onUpdate, isPaidPlan }: EventListProps) {
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'ABERTO':
        return '#4CAF50';
      case 'ENCERRADO':
        return '#FFC107';
      case 'CANCELADO':
        return '#F44336';
      case 'CONCLUIDO':
        return '#2196F3';
      default:
        return '#666';
    }
  };

  const handleEdit = (eventId: string) => {
    router.push(`/events/${eventId}/edit`);
  };

  const handleViewCandidacies = (eventId: string) => {
    router.push(`/events/${eventId}/candidacies`);
  };

  return (
    <View style={styles.container}>
      {events.map((event) => (
        <View key={event.id} style={styles.eventItem}>
          <View style={styles.eventHeader}>
            <Text style={styles.eventTitle}>{event.title}</Text>
            <View style={[styles.statusBadge, { backgroundColor: getStatusColor(event.status) }]}>
              <Text style={styles.statusText}>{i18n.t(`events.status.${event.status.toLowerCase()}`)}</Text>
            </View>
          </View>

          <View style={styles.eventDetails}>
            <Text style={styles.detailText}>
              <Ionicons name="calendar" size={16} /> {new Date(event.startDate).toLocaleDateString()}
            </Text>
            <Text style={styles.detailText}>
              <Ionicons name="location" size={16} /> {event.location}
            </Text>
            <Text style={styles.detailText}>
              <Ionicons name="musical-notes" size={16} /> {event.styles.join(', ')}
            </Text>
          </View>

          <View style={styles.cacheInfo}>
            <Text style={styles.cacheText}>
              {i18n.t('events.cache')}: {event.minCache}
              {isPaidPlan && ` - ${event.maxCache}`}
            </Text>
          </View>

          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => handleEdit(event.id)}
            >
              <Ionicons name="create-outline" size={24} color="#007AFF" />
              <Text style={styles.actionText}>{i18n.t('common.button.edit')}</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => handleViewCandidacies(event.id)}
            >
              <Ionicons name="people-outline" size={24} color="#007AFF" />
              <Text style={styles.actionText}>{i18n.t('events.viewCandidacies')}</Text>
            </TouchableOpacity>
          </View>
        </View>
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginTop: 20,
  },
  eventItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  eventHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  eventTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
    marginLeft: 10,
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  eventDetails: {
    marginBottom: 10,
  },
  detailText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  cacheInfo: {
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 10,
    marginTop: 10,
  },
  cacheText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 10,
  },
  actionButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 10,
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    marginHorizontal: 5,
  },
  actionText: {
    marginLeft: 5,
    color: '#007AFF',
    fontSize: 16,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\Layout.tsx ---
import React from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Navigation } from './Navigation';

interface LayoutProps {
  children: React.ReactNode;
}

export function Layout({ children }: LayoutProps) {
  return (
    <SafeAreaView style={styles.safeArea} edges={['top', 'left', 'right']}>
      <View style={styles.container}>
        <View style={styles.content}>
          {children}
        </View>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  container: {
    flex: 1,
    alignItems: 'center',
  },
  content: {
    width: '100%',
    maxWidth: Platform.select({ web: 600, default: '100%' }),
    flex: 1,
    padding: 20,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\LineChart.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

interface LineChartProps {
  data: number[];
  labels: string[];
  color: string;
}

export function LineChart({ data, labels, color }: LineChartProps) {
  const maxValue = Math.max(...data, 1);
  const points = data.map((value, index) => ({
    x: (index / (data.length - 1)) * 100,
    y: ((maxValue - value) / maxValue) * 100,
  }));

  const path = points
    .map((point, index) => 
      `${index === 0 ? 'M' : 'L'} ${point.x} ${point.y}`
    )
    .join(' ');

  return (
    <View style={styles.container}>
      <View style={styles.chart}>
        <svg
          style={styles.svg}
          viewBox="0 0 100 100"
          preserveAspectRatio="none"
        >
          <path
            d={path}
            stroke={color}
            strokeWidth="2"
            fill="none"
          />
        </svg>

        <View style={styles.gridLines}>
          {[0, 1, 2, 3].map(i => (
            <View
              key={i}
              style={[styles.gridLine, { top: `${(i / 3) * 100}%` }]}
            />
          ))}
        </View>
      </View>

      <View style={styles.labels}>
        {labels.filter((_, i) => i % 5 === 0).map((label, i) => (
          <Text key={i} style={styles.label}>
            {label}
          </Text>
        ))}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    height: 200,
  },
  chart: {
    flex: 1,
    borderLeftWidth: 1,
    borderBottomWidth: 1,
    borderColor: '#ddd',
    marginBottom: 20,
  },
  svg: {
    position: 'absolute',
    width: '100%',
    height: '100%',
  },
  gridLines: {
    position: 'absolute',
    width: '100%',
    height: '100%',
  },
  gridLine: {
    position: 'absolute',
    width: '100%',
    height: 1,
    backgroundColor: '#f0f0f0',
  },
  labels: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 10,
  },
  label: {
    fontSize: 12,
    color: '#666',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\MediaList.tsx ---
import React from 'react';
import { View, Text, StyleSheet, Image, TouchableOpacity, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { auth, db, storage } from '../services/firebase';
import { doc, deleteDoc, updateDoc, increment } from 'firebase/firestore';
import { ref, deleteObject } from 'firebase/storage';
import i18n from '../i18n';
import type { Media } from '../types';

interface MediaListProps {
  medias: Media[];
  onUpdate: () => void;
  isPaidPlan: boolean;
}

export function MediaList({ medias, onUpdate, isPaidPlan }: MediaListProps) {
  const handleDelete = async (media: Media) => {
    try {
      // Delete from Storage
      const storageRef = ref(storage, media.url);
      await deleteObject(storageRef);

      // Delete from Firestore
      await deleteDoc(doc(db, 'media', media.id));

      // Update user's storage usage
      if (auth.currentUser) {
        await updateDoc(doc(db, 'users', auth.currentUser.uid), {
          bucketUse: increment(-media.sizeMB)
        });
      }

      Alert.alert(i18n.t('common.success.mediaDeleted'));
      onUpdate();
    } catch (error) {
      console.error('Error deleting media:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleHighlight = async (media: Media) => {
    if (!isPaidPlan) {
      Alert.alert(i18n.t('common.error.storage.limit'));
      return;
    }

    try {
      await updateDoc(doc(db, 'media', media.id), {
        highlighted: !media.highlighted
      });
      onUpdate();
    } catch (error) {
      console.error('Error updating media:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleLike = async (media: Media) => {
    try {
      await updateDoc(doc(db, 'media', media.id), {
        likesCount: increment(1)
      });
      onUpdate();
    } catch (error) {
      console.error('Error liking media:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const handleFavorite = async (media: Media) => {
    try {
      await updateDoc(doc(db, 'media', media.id), {
        favoritesCount: increment(1)
      });
      onUpdate();
    } catch (error) {
      console.error('Error favoriting media:', error);
      Alert.alert(i18n.t('common.error.unknown'));
    }
  };

  const renderMediaIcon = (type: string) => {
    switch (type) {
      case 'photo':
        return <Ionicons name="image" size={24} color="#007AFF" />;
      case 'video':
        return <Ionicons name="videocam" size={24} color="#007AFF" />;
      case 'audio':
        return <Ionicons name="musical-notes" size={24} color="#007AFF" />;
      default:
        return null;
    }
  };

  return (
    <View style={styles.container}>
      {medias.map((media) => (
        <View key={media.id} style={[styles.mediaItem, media.highlighted && styles.highlighted]}>
          <View style={styles.mediaHeader}>
            {renderMediaIcon(media.type)}
            <Text style={styles.mediaTitle}>{media.title}</Text>
            {media.highlighted && (
              <Ionicons name="star" size={20} color="#FFD700" style={styles.highlightIcon} />
            )}
          </View>

          {media.type === 'photo' && (
            <Image source={{ uri: media.url }} style={styles.mediaPreview} />
          )}

          <Text style={styles.mediaDescription}>{media.description}</Text>

          <View style={styles.statsContainer}>
            <Text style={styles.statsText}>
              <Ionicons name="eye" size={16} /> {media.viewsCount}
            </Text>
            <Text style={styles.statsText}>
              <Ionicons name="heart" size={16} /> {media.likesCount}
            </Text>
            <Text style={styles.statsText}>
              <Ionicons name="star" size={16} /> {media.favoritesCount}
            </Text>
          </View>

          <View style={styles.actionButtons}>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => handleLike(media)}
            >
              <Ionicons name="heart-outline" size={24} color="#007AFF" />
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => handleFavorite(media)}
            >
              <Ionicons name="star-outline" size={24} color="#007AFF" />
            </TouchableOpacity>

            {isPaidPlan && (
              <TouchableOpacity
                style={styles.actionButton}
                onPress={() => handleHighlight(media)}
              >
                <Ionicons
                  name={media.highlighted ? "star" : "star-outline"}
                  size={24}
                  color="#FFD700"
                />
              </TouchableOpacity>
            )}

            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => handleDelete(media)}
            >
              <Ionicons name="trash-outline" size={24} color="#FF3B30" />
            </TouchableOpacity>
          </View>
        </View>
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginTop: 20,
  },
  mediaItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  highlighted: {
    borderColor: '#FFD700',
    borderWidth: 2,
  },
  mediaHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  mediaTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 10,
    flex: 1,
  },
  highlightIcon: {
    marginLeft: 10,
  },
  mediaPreview: {
    width: '100%',
    height: 200,
    borderRadius: 4,
    marginBottom: 10,
  },
  mediaDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 10,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 10,
  },
  statsText: {
    fontSize: 14,
    color: '#666',
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 10,
  },
  actionButton: {
    padding: 5,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\MediaUpload.tsx ---
import React, { useState } from 'react';
import { View, Text, TextInput, StyleSheet, Alert, Platform } from 'react-native';
import { Button } from './Button';
import { Picker } from '@react-native-picker/picker';
import { auth, db, storage } from '../services/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { collection, addDoc, doc, updateDoc, increment } from 'firebase/firestore';
import i18n from '../i18n';
import type { MediaType } from '../types';

interface MediaUploadProps {
  onClose: () => void;
  onSuccess: () => void;
}

export function MediaUpload({ onClose, onSuccess }: MediaUploadProps) {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [type, setType] = useState<MediaType>('photo');
  const [file, setFile] = useState<File | null>(null);
  const [loading, setLoading] = useState(false);

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files && files.length > 0) {
      setFile(files[0]);
    }
  };

  const handleUpload = async () => {
    if (!file || !auth.currentUser) return;

    setLoading(true);
    try {
      // Calculate file size in MB
      const sizeMB = file.size / (1024 * 1024);

      // Get user's current storage usage
      const userDoc = await db.collection('users').doc(auth.currentUser.uid).get();
      const userData = userDoc.data();
      const currentUsage = userData?.bucketUse || 0;
      const storageLimit = userData?.planId === 'paid' ? 2048 : 100;

      if (currentUsage + sizeMB > storageLimit) {
        Alert.alert(i18n.t('common.error.storage.limit'));
        return;
      }

      // Upload file to Storage
      const storageRef = ref(storage, `media/${auth.currentUser.uid}/${file.name}`);
      await uploadBytes(storageRef, file);
      const downloadURL = await getDownloadURL(storageRef);

      // Add media document to Firestore
      const mediaDoc = await addDoc(collection(db, 'media'), {
        userId: auth.currentUser.uid,
        type,
        url: downloadURL,
        sizeMB,
        title,
        description,
        highlighted: false,
        viewsCount: 0,
        likesCount: 0,
        favoritesCount: 0,
        createdAt: new Date(),
      });

      // Update user's storage usage
      await updateDoc(doc(db, 'users', auth.currentUser.uid), {
        bucketUse: increment(sizeMB)
      });

      Alert.alert(i18n.t('common.success.mediaUploaded'));
      onSuccess();
    } catch (error) {
      console.error('Error uploading media:', error);
      Alert.alert(i18n.t('common.error.storage.upload'));
    } finally {
      setLoading(false);
    }
  };

  if (Platform.OS !== 'web') {
    return (
      <View style={styles.container}>
        <Text style={styles.notice}>
          Media upload is currently only available on web platform
        </Text>
        <Button title={i18n.t('common.button.close')} onPress={onClose} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{i18n.t('portfolio.upload.title')}</Text>

      <View style={styles.form}>
        <Text style={styles.label}>{i18n.t('portfolio.upload.type')}</Text>
        <Picker
          selectedValue={type}
          onValueChange={(value) => setType(value as MediaType)}
          style={styles.picker}
        >
          <Picker.Item label={i18n.t('portfolio.media.photo')} value="photo" />
          <Picker.Item label={i18n.t('portfolio.media.video')} value="video" />
          <Picker.Item label={i18n.t('portfolio.media.audio')} value="audio" />
        </Picker>

        <Text style={styles.label}>{i18n.t('portfolio.upload.title_field')}</Text>
        <TextInput
          style={styles.input}
          value={title}
          onChangeText={setTitle}
        />

        <Text style={styles.label}>{i18n.t('portfolio.upload.description')}</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={description}
          onChangeText={setDescription}
          multiline
          numberOfLines={4}
        />

        <input
          type="file"
          accept={type === 'photo' ? 'image/*' : type === 'video' ? 'video/*' : 'audio/*'}
          onChange={handleFileSelect}
          style={{ marginBottom: 15 }}
        />

        <View style={styles.buttonContainer}>
          <Button
            title={i18n.t('common.button.upload')}
  )
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\Navigation.tsx ---
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Platform } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router, usePathname } from 'expo-router';
import i18n from '../i18n';

export function Navigation() {
  const pathname = usePathname();
  const isArtist = pathname.includes('artist');
  const isContractor = pathname.includes('contractor');

  if (!isArtist && !isContractor) return null;

  const handleNavigation = (path: string) => {
    router.push(path);
  };

  const baseRoute = isArtist ? '/home-artist' : '/home-contractor';
  const profileRoute = isArtist ? '/edit-artist-profile' : '/edit-contractor-profile';

  return (
    <View style={styles.container}>
      <TouchableOpacity
        style={styles.navItem}
        onPress={() => handleNavigation(baseRoute)}
      >
        <Ionicons name="home-outline" size={24} color="#007AFF" />
        <Text style={styles.navText}>{i18n.t('navigation.home')}</Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={styles.navItem}
        onPress={() => handleNavigation(profileRoute)}
      >
        <Ionicons name="person-outline" size={24} color="#007AFF" />
        <Text style={styles.navText}>{i18n.t('navigation.profile')}</Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={styles.navItem}
        onPress={() => handleNavigation('/login')}
      >
        <Ionicons name="log-out-outline" size={24} color="#007AFF" />
        <Text style={styles.navText}>{i18n.t('navigation.logout')}</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 10,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    ...Platform.select({
      web: {
        maxWidth: 600,
        marginHorizontal: 'auto',
      },
    }),
  },
  navItem: {
    alignItems: 'center',
    padding: 10,
  },
  navText: {
    marginTop: 5,
    fontSize: 12,
    color: '#007AFF',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\StorageUsage.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import i18n from '../i18n';
import type { User } from '../types';

interface StorageUsageProps {
  user: User | null;
}

export function StorageUsage({ user }: StorageUsageProps) {
  if (!user) return null;

  const storageLimit = user.planId === 'paid' ? 2048 : 100;
  const usedStorage = user.bucketUse || 0;
  const freeStorage = storageLimit - usedStorage;
  const usagePercentage = (usedStorage / storageLimit) * 100;

  return (
    <View style={styles.container}>
      <View style={styles.infoContainer}>
        <Text style={styles.label}>{i18n.t('portfolio.storage.used')}</Text>
        <Text style={styles.value}>{usedStorage.toFixed(1)} MB</Text>
      </View>

      <View style={styles.progressContainer}>
        <View style={[styles.progressBar, { width: `${usagePercentage}%` }]} />
      </View>

      <View style={styles.infoContainer}>
        <Text style={styles.label}>{i18n.t('portfolio.storage.total')}</Text>
        <Text style={styles.value}>{storageLimit} MB</Text>
      </View>

      <View style={styles.infoContainer}>
        <Text style={styles.label}>{i18n.t('portfolio.storage.free')}</Text>
        <Text style={styles.value}>{freeStorage.toFixed(1)} MB</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  infoContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 10,
  },
  label: {
    fontSize: 14,
    color: '#666',
  },
  value: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#333',
  },
  progressContainer: {
    height: 8,
    backgroundColor: '#f0f0f0',
    borderRadius: 4,
    marginVertical: 10,
    overflow: 'hidden',
  },
  progressBar: {
    height: '100%',
    backgroundColor: '#007AFF',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\components\UserRating.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface UserRatingProps {
  rating: number;
  reviewCount: number;
  showCount?: boolean;
}

export function UserRating({ rating, reviewCount, showCount = true }: UserRatingProps) {
  const roundedRating = Math.round(rating * 2) / 2;
  const fullStars = Math.floor(roundedRating);
  const hasHalfStar = roundedRating % 1 !== 0;

  return (
    <View style={styles.container}>
      <View style={styles.starsContainer}>
        {[...Array(5)].map((_, index) => {
          if (index < fullStars) {
            return <Ionicons key={index} name="star" size={16} color="#FFD700" />;
          } else if (index === fullStars && hasHalfStar) {
            return <Ionicons key={index} name="star-half" size={16} color="#FFD700" />;
          } else {
            return <Ionicons key={index} name="star-outline" size={16} color="#FFD700" />;
          }
        })}
      </View>
      <Text style={styles.ratingText}>
        {rating.toFixed(1)}
        {showCount && ` (${reviewCount})`}
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  starsContainer: {
    flexDirection: 'row',
    marginRight: 5,
  },
  ratingText: {
    fontSize: 14,
    color: '#666',
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\i18n\en.json ---
{
  "admin": {
    "feedbackCriteria": {
      "title": "Feedback Criteria",
      "form": {
        "name": "Criterion Name",
        "namePlaceholder": "Enter criterion name",
        "weight": "Weight",
        "appliesTo": "Applies To"
      },
      "appliesTo": {
        "label": "Applies to",
        "artist": "Artist",
        "contractor": "Contractor",
        "both": "Both"
      },
      "weight": "Weight",
      "status": {
        "active": "Active",
        "inactive": "Inactive"
      },
      "success": {
        "created": "Feedback criterion created successfully",
        "updated": "Feedback criterion updated successfully",
        "activated": "Feedback criterion activated successfully",
        "deactivated": "Feedback criterion deactivated successfully"
      }
    }
  }
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\i18n\index.ts ---
import * as Localization from 'expo-localization';
import { I18n } from 'i18n-js';
import en from './en.json';
import pt from './pt.json';

const i18n = new I18n({
  en,
  pt,
});

i18n.locale = Localization.locale.split('-')[0];
i18n.enableFallback = true;
i18n.defaultLocale = 'en';

export default i18n;

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\i18n\pt.json ---
{
  "admin": {
    "feedbackCriteria": {
      "title": "Critérios de Feedback",
      "form": {
        "name": "Nome do Critério",
        "namePlaceholder": "Digite o nome do critério",
        "weight": "Peso",
        "appliesTo": "Aplica-se a"
      },
      "appliesTo": {
        "label": "Aplica-se a",
        "artist": "Artista",
        "contractor": "Contratante",
        "both": "Ambos"
      },
      "weight": "Peso",
      "status": {
        "active": "Ativo",
        "inactive": "Inativo"
      },
      "success": {
        "created": "Critério de feedback criado com sucesso",
        "updated": "Critério de feedback atualizado com sucesso",
        "activated": "Critério de feedback ativado com sucesso",
        "deactivated": "Critério de feedback desativado com sucesso"
      }
    }
  }
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\screens\HomeScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Button } from '../components/Button';
import { auth } from '../services/firebase';
import { signOut } from 'firebase/auth';
import { router } from 'expo-router';

export const HomeScreen = () => {
  const handleSignOut = async () => {
    try {
      await signOut(auth);
      router.replace('/login');
    } catch (error) {
      console.error('Error signing out:', error);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Welcome!</Text>
      <Text style={styles.subtitle}>You are logged in as {auth.currentUser?.email}</Text>
      <Button title="Sign Out" onPress={handleSignOut} variant="secondary" />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 30,
  },
});

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\services\autoOffer.ts ---
import { collection, query, where, getDocs, addDoc, doc, getDoc, updateDoc, increment } from 'firebase/firestore';
import { db } from './firebase';
import type { Event, User } from '../types';

export async function processAutoOffers(event: Event) {
  try {
    // Get all artists with auto-offer enabled
    const artistsQuery = query(
      collection(db, 'users'),
      where('role', '==', 'artist'),
      where('autoOffer.enabled', '==', true)
    );

    const artistsSnapshot = await getDocs(artistsQuery);

    for (const artistDoc of artistsSnapshot.docs) {
      const artist = artistDoc.data() as User;

      // Check if artist meets criteria
      const autoOffer = artist.autoOffer!;
      const meetsMinCache = event.minCache >= autoOffer.minCache;
      const hasMatchingGenre = event.styles.some(style => 
        autoOffer.genres.includes(style)
      );

      if (meetsMinCache && hasMatchingGenre) {
        // Check if already applied
        const existingCandidacy = await getDocs(query(
          collection(db, 'candidacies'),
          where('artistId', '==', artistDoc.id),
          where('eventId', '==', event.id)
        ));

        if (existingCandidacy.empty) {
          // Check credits for free plan
          if (artist.planId === 'free') {
            if (artist.credits < 1) {
              console.log(`Artist ${artist.email} has no credits for auto-offer`);
              continue;
            }

            // Deduct credit
            await updateDoc(doc(db, 'users', artistDoc.id), {
              credits: increment(-1)
            });
          }

          // Create candidacy
          await addDoc(collection(db, 'candidacies'), {
            artistId: artistDoc.id,
            eventId: event.id,
            status: 'PENDENTE',
            createdAt: new Date(),
            autoGenerated: true,
          });

          console.log(`Auto-offer created for artist ${artist.email}`);
        }
      }
    }
  } catch (error) {
    console.error('Error processing auto-offers:', error);
  }
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\services\autoPromote.ts ---
import { collection, query, where, getDocs } from 'firebase/firestore';
import { db } from './firebase';
import type { Event, User } from '../types';

export async function notifyMatchingArtists(event: Event) {
  try {
    // Get all artists that match event criteria
    const artistsQuery = query(
      collection(db, 'users'),
      where('role', '==', 'artist')
    );

    const artistsSnapshot = await getDocs(artistsQuery);

    for (const artistDoc of artistsSnapshot.docs) {
      const artist = artistDoc.data() as User;

      // Get artist profile
      const profileDoc = await getDocs(query(
        collection(db, 'artistProfiles'),
        where('userId', '==', artistDoc.id)
      ));

      if (!profileDoc.empty) {
        const profile = profileDoc.docs[0].data();
        const matchesGenres = event.styles.some(style => 
          profile.genres.includes(style)
        );
        const matchesCache = event.minCache >= profile.minimumCache;

        if (matchesGenres && matchesCache) {
          // For now, just log the notification
          console.log(`Would notify artist ${artist.email} about event ${event.title}`);
          
          // TODO: Implement actual push notifications
          // This would be the place to send push notifications
          // using a service like Firebase Cloud Messaging
        }
      }
    }
  } catch (error) {
    console.error('Error notifying artists:', error);
  }
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\services\firebase.ts ---
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getStorage } from 'firebase/storage';
import Constants from 'expo-constants';

const extra = Constants.expoConfig?.extra;

const firebaseConfig = {
  apiKey: extra?.firebaseApiKey,
  authDomain: extra?.firebaseAuthDomain,
  projectId: extra?.firebaseProjectId,
  storageBucket: extra?.firebaseStorageBucket,
  messagingSenderId: extra?.firebaseMessagingSenderId,
  appId: extra?.firebaseAppId,
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);

// Initialize Firebase Authentication and get a reference to the service
export const auth = getAuth(app);

// Initialize Cloud Firestore and get a reference to the service
export const db = getFirestore(app);

// Initialize Cloud Storage and get a reference to the service
export const storage = getStorage(app);

export default app;

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\services\notifications.ts ---
import * as Notifications from 'expo-notifications';
import * as Device from 'expo-device';
import { Platform } from 'react-native';
import { auth, db } from './firebase';
import { doc, updateDoc } from 'firebase/firestore';

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: true,
  }),
});

export async function registerForPushNotificationsAsync() {
  let token;

  if (Platform.OS === 'web') {
    console.log('Push notifications are not supported on web platform');
    return;
  }

  if (Device.isDevice) {
    const { status: existingStatus } = await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;

    if (existingStatus !== 'granted') {
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }

    if (finalStatus !== 'granted') {
      console.log('Failed to get push token for push notification!');
      return;
    }

    token = (await Notifications.getExpoPushTokenAsync({
      projectId: process.env.EXPO_PUBLIC_PROJECT_ID,
    })).data;
  }

  if (Platform.OS === 'android') {
    Notifications.setNotificationChannelAsync('default', {
      name: 'default',
      importance: Notifications.AndroidImportance.MAX,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: '#FF231F7C',
    });
  }

  return token;
}

export async function updatePushToken(token: string) {
  if (!auth.currentUser) return;

  try {
    await updateDoc(doc(db, 'users', auth.currentUser.uid), {
      pushToken: token,
      pushTokenUpdatedAt: new Date(),
    });
  } catch (error) {
    console.error('Error updating push token:', error);
  }
}

export async function sendPushNotification(
  userIds: string[],
  title: string,
  body: string,
  data?: Record<string, string>
) {
  if (Platform.OS === 'web') {
    console.log('Would send push notification:', { title, body, data });
    return;
  }

  try {
    const messages = userIds.map(userId => ({
      to: `ExponentPushToken[${userId}]`,
      sound: 'default',
      title,
      body,
      data: data || {},
    }));

    await fetch('https://exp.host/--/api/v2/push/send', {
      method: 'POST',
      headers: {
        Accept: 'application/json',
        'Accept-encoding': 'gzip, deflate',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(messages),
    });
  } catch (error) {
    console.error('Error sending push notification:', error);
  }
}

--- Conteúdo do arquivo: C:\Users\Dell\Desktop\WIP\temp\bolt-completo\project\src\types\index.ts ---
// Add to existing types
export interface User {
  // ... existing fields
  pushToken?: string;
  pushTokenUpdatedAt?: Date;
}

export interface Notification {
  id: string;
  type: 'chat' | 'event' | 'candidacy';
  title: string;
  body: string;
  senderId: string;
  receiverId: string;
  seen: boolean;
  data?: Record<string, string>;
  createdAt: Date;
  chatId?: string;
  eventId?: string;
  candidacyId?: string;
}

